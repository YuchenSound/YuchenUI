- # YuchenUI 架构重构详细文档

  **文档版本**: 1.0
   **创建日期**: 2025年1月
   **目标**: 将YuchenUI从窗口框架重构为纯UI库 + 可选平台层

  ------

  ## 📋 目录

  1. [重构目标与原则](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#1-重构目标与原则)
  2. [新架构设计](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#2-新架构设计)
  3. [关键设计决策](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#3-关键设计决策)
  4. [文件清单与改动](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#4-文件清单与改动)
  5. [详细重构指南](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#5-详细重构指南)
  6. [测试验证](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#6-测试验证)
  7. [工作分配建议](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#7-工作分配建议)

  ------

  ## 1. 重构目标与原则

  ### 1.1 目标

  将YuchenUI拆分为两个独立的库：

  1. **YuchenUI Core** - 纯UI渲染库
     - 不依赖任何窗口系统
     - 可嵌入GLFW、VST3、Web、游戏引擎等
     - 完整的Widget系统、主题、焦点管理
  2. **YuchenUI Platform** - 平台窗口层（可选）
     - 提供原生窗口管理
     - 封装操作系统API（Cocoa/Win32）
     - 依赖Core层

  ### 1.2 核心原则

  ```
  ✅ 单向依赖：Platform → Core，Core不依赖Platform
  ✅ 接口抽象：Core定义接口，Platform提供实现
  ✅ 纯净Core：Core层零窗口系统依赖
  ✅ 独立编译：Core可单独编译成库
  ```

  ------

  ## 2. 新架构设计

  ### 2.1 分层架构

  ```
  ┌─────────────────────────────────────────────┐
  │  用户应用层                                  │
  │  ├─ 纯UI模式：UIContext + 自定义窗口         │
  │  └─ 平台模式：WindowManager + BaseWindow    │
  └─────────────────────────────────────────────┘
                      ↓
  ┌─────────────────────────────────────────────┐
  │  YuchenUI Platform (可选)                    │
  │  ├─ WindowManager                           │
  │  ├─ BaseWindow                              │
  │  ├─ WindowImpl (macOS/Windows)             │
  │  ├─ MetalRenderer (实现IGraphicsBackend)    │
  │  └─ MacEventManager                         │
  └─────────────────────────────────────────────┘
                      ↓ 依赖
  ┌─────────────────────────────────────────────┐
  │  YuchenUI Core (纯UI)                        │
  │  ├─ UIContext (新核心类)                     │
  │  ├─ IUIContent (替代IWindowContent)         │
  │  ├─ Widget系统 (Button/TextInput等)         │
  │  ├─ IGraphicsBackend (抽象接口)             │
  │  ├─ RenderList                              │
  │  ├─ TextRenderer / FontManager              │
  │  ├─ ThemeManager                            │
  │  └─ FocusManager                            │
  └─────────────────────────────────────────────┘
  ```

  ### 2.2 数据流

  **输入流：**

  ```
  平台事件 → EventManager(转换) → UIContext → IUIContent → Widget树
  ```

  **渲染流：**

  ```
  Widget树 → RenderList → IGraphicsBackend → GPU
  ```

  ------

  ## 3. 关键设计决策

  ### 3.1 UIContext职责

  UIContext是Core层的核心入口，负责：

  | 职责     | 说明                          |
  | -------- | ----------------------------- |
  | 内容管理 | 持有IUIContent实例            |
  | 输入路由 | 转发鼠标/键盘/文本输入到组件  |
  | 渲染协调 | 调用IUIContent生成RenderList  |
  | 焦点管理 | 持有FocusManager，处理Tab导航 |
  | 鼠标捕获 | 管理当前捕获输入的组件        |
  | 视口信息 | 提供尺寸、DPI等信息           |

  **不负责：**

  - ❌ 创建窗口
  - ❌ 创建渲染器
  - ❌ 事件捕获（只处理已转换的事件）

  ### 3.2 IGraphicsBackend接口

  **位置**: `core/include/YuchenUI/rendering/IGraphicsBackend.h`

  定义渲染器的抽象接口，Core层定义，Platform层实现。

  ```cpp
  class IGraphicsBackend {
  public:
      virtual ~IGraphicsBackend() = default;
      
      // 帧管理
      virtual void beginFrame() = 0;
      virtual void endFrame() = 0;
      
      // 渲染
      virtual void executeRenderCommands(const RenderList& commands) = 0;
      
      // 纹理管理（给TextRenderer/TextureCache用）
      virtual void* createTexture2D(uint32_t width, uint32_t height, 
                                     TextureFormat format) = 0;
      virtual void updateTexture2D(void* texture, uint32_t x, uint32_t y,
                                   uint32_t width, uint32_t height,
                                   const void* data, size_t bytesPerRow) = 0;
      virtual void destroyTexture(void* texture) = 0;
      
      // 视口信息
      virtual Vec2 getRenderSize() const = 0;
  };
  ```

  ### 3.3 事件处理机制

  **EventManager改为纯转换器：**

  ```cpp
  // 之前（有状态）
  class EventManager {
      EventQueue m_queue;
      EventCallback m_callback;
      void handleNativeEvent(void* event);  // 放入队列
      Event getNextEvent();
  };
  
  // 之后（无状态）
  class EventManager {
      Event convertNativeEvent(void* event);  // 纯转换
  };
  ```

  **事件流：**

  ```
  NSEvent → EventManager::convert() → Event对象 → UIContext::handleXxx()
  ```

  ### 3.4 组件树管理

  **组件所有权：**

  ```
  IUIContent → Widget → 子Widget → UIComponent
      ↑          ↑         ↑           ↑
     拥有       拥有      拥有        不拥有任何东西
  ```

  **上下文引用：**

  ```
  UIContext ←─── IUIContent ←─── Widget ←─── UIComponent
      ↑            持有引用       持有引用      持有引用
     根对象
  ```

  ### 3.5 DPI缩放管理

  **集中管理：**

  ```cpp
  UIContext::setDPIScale(2.0f);  // 设置
  
  // 各组件从上下文获取
  float dpi = component->getOwnerContext()->getDPIScale();
  ```

  ### 3.6 菜单弹出机制

  Menu在Core层，但弹出行为由Platform层实现：

  ```cpp
  // Core层
  class Menu {
      using PopupHandler = std::function<void(const Vec2& screenPos, Menu*)>;
      void setPopupHandler(PopupHandler handler);
      void popup(float x, float y);  // 触发handler
  };
  
  // Platform层注入
  menu->setPopupHandler([](const Vec2& pos, Menu* menu) {
      // macOS原生菜单弹出
  });
  ```

  ------

  ## 4. 文件清单与改动

  ### 4.1 Core层文件（45个）

  #### 新增文件（3个）

  | 文件路径                             | 类型   | 说明          |
  | ------------------------------------ | ------ | ------------- |
  | `core/include/YuchenUI/UIContext.h`  | 头文件 | 核心入口类    |
  | `core/src/UIContext.cpp`             | 实现   | UIContext实现 |
  | `core/include/YuchenUI/IUIContent.h` | 头文件 | 内容接口      |

  #### 重度重构（10个）

  | 文件路径                                            | 改动级别 | 关键改动             |
  | --------------------------------------------------- | -------- | -------------------- |
  | `core/include/YuchenUI/widgets/UIComponent.h`       | 🔴 重度   | 去掉BaseWindow依赖   |
  | `core/src/widgets/UIComponent.cpp`                  | 🔴 重度   | 重构captureMouse等   |
  | `core/include/YuchenUI/widgets/Widget.h`            | 🔴 重度   | 修改addChild逻辑     |
  | `core/src/widgets/Widget.cpp`                       | 🔴 重度   | 去掉窗口生命周期     |
  | `core/include/YuchenUI/rendering/GraphicsContext.h` | 🔴 重度   | 变成IGraphicsBackend |
  | `core/include/YuchenUI/widgets/TextInput.h`         | 🔴 重度   | IME改为上下文获取    |
  | `core/src/widgets/TextInput.cpp`                    | 🔴 重度   | 焦点/IME逻辑重构     |
  | `core/include/YuchenUI/focus/FocusManager.h`        | 🟡 中度   | 持有UIContext*       |
  | `core/src/focus/FocusManager.cpp`                   | 🟡 中度   | 修改所有者引用       |
  | `core/include/YuchenUI/menu/Menu.h`                 | 🟡 中度   | 添加PopupHandler     |

  #### 中度修改（12个Widget）

  | 文件              | 改动内容                         |
  | ----------------- | -------------------------------- |
  | Button.h/cpp      | setOwnerWindow → setOwnerContext |
  | TextLabel.h/cpp   | 同上                             |
  | TextBlock.h/cpp   | 同上                             |
  | Frame.h/cpp       | 同上                             |
  | GroupBox.h/cpp    | 同上                             |
  | Image.h/cpp       | 同上                             |
  | CheckBox.h/cpp    | 同上                             |
  | RadioButton.h/cpp | 同上                             |
  | ComboBox.h/cpp    | 同上 + 菜单弹出改为回调          |
  | SpinBox.h/cpp     | 同上                             |
  | ScrollArea.h/cpp  | 同上                             |
  | IScrollable.h     | 无改动                           |

  #### 轻微修改（20个）

  这些文件基本保持不变，只需移动到`core/`目录：

  | 目录       | 文件数 | 说明                                                         |
  | ---------- | ------ | ------------------------------------------------------------ |
  | core/      | 5      | Assert.h, Colors.h, Config.h, Types.h, Validation.h          |
  | text/      | 6      | Font.h/cpp, FontManager.h/cpp, TextRenderer.h/cpp, GlyphCache.h/cpp, TextUtils.h/cpp |
  | theme/     | 4      | Theme.h/cpp, ThemeManager.h/cpp                              |
  | rendering/ | 2      | RenderList.h/cpp                                             |
  | image/     | 2      | ImageDecoder.h/cpp, TextureCache.h/cpp（轻微修改）           |
  | debugging/ | 1      | debug.h                                                      |

  ------

  ### 4.2 Platform层文件（15个）

  #### 移动+重构（8个）

  | 原路径                                     | 新路径                                              | 改动  |
  | ------------------------------------------ | --------------------------------------------------- | ----- |
  | `include/YuchenUI/windows/Window.h`        | `platform/include/YuchenUI/windows/Window.h`        | 无    |
  | `include/YuchenUI/windows/BaseWindow.h`    | `platform/include/YuchenUI/windows/BaseWindow.h`    | 🔴重度 |
  | `src/windows/BaseWindow.cpp`               | `platform/src/windows/BaseWindow.cpp`               | 🔴重度 |
  | `include/YuchenUI/windows/WindowManager.h` | `platform/include/YuchenUI/windows/WindowManager.h` | 🟡中度 |
  | `src/windows/WindowManager.cpp`            | `platform/src/windows/WindowManager.cpp`            | 🟡中度 |
  | `include/YuchenUI/platform/WindowImpl.h`   | `platform/include/YuchenUI/platform/WindowImpl.h`   | 轻微  |
  | `src/platform/macos/MacOSWindowImpl.mm`    | `platform/src/macos/MacOSWindowImpl.mm`             | 🟡中度 |
  | `src/platform/macos/MacEventManager.mm`    | `platform/src/macos/MacEventManager.mm`             | 🟡中度 |

  #### 重度重构（3个）

  | 文件                                                   | 改动说明                          |
  | ------------------------------------------------------ | --------------------------------- |
  | `platform/src/macos/MetalRenderer.mm`                  | 实现IGraphicsBackend接口          |
  | `platform/src/macos/MacMenuImpl.mm`                    | 适配新的Menu回调机制              |
  | `platform/include/YuchenUI/platform/PlatformBackend.h` | 工厂方法改为返回IGraphicsBackend* |

  #### 移动不改动（4个）

  | 文件                                              | 说明     |
  | ------------------------------------------------- | -------- |
  | `platform/include/YuchenUI/events/EventManager.h` | 移动位置 |
  | `platform/include/YuchenUI/platform/MenuImpl.h`   | 移动位置 |
  | `platform/include/YuchenUI/utils/Clipboard.h`     | 移动位置 |
  | `platform/src/utils/Clipboard.cpp`                | 移动位置 |

  #### 删除文件（2个）

  | 文件                                        | 原因             |
  | ------------------------------------------- | ---------------- |
  | `include/YuchenUI/windows/IWindowContent.h` | 被IUIContent替代 |
  | `src/windows/IWindowContent.cpp`            | 被IUIContent替代 |

  ------

  ## 5. 详细重构指南

  ### 5.1 Phase 1: Core层基础构建

  #### 5.1.1 创建UIContext.h

  **文件**: `core/include/YuchenUI/UIContext.h`

  ```cpp
  #pragma once
  
  #include "YuchenUI/core/Types.h"
  #include "YuchenUI/events/Event.h"
  #include <memory>
  
  namespace YuchenUI {
  
  class IUIContent;
  class IGraphicsBackend;
  class FocusManager;
  class UIComponent;
  
  class UIContext {
  public:
      UIContext();
      ~UIContext();
      
      // === 内容管理 ===
      void setContent(std::unique_ptr<IUIContent> content);
      IUIContent* getContent() const;
      
      // === 渲染循环 ===
      void beginFrame();
      void render(RenderList& outCommandList);
      void endFrame();
      
      // === 输入处理 ===
      bool handleMouseMove(const Vec2& position);
      bool handleMouseClick(const Vec2& position, bool pressed);
      bool handleMouseWheel(const Vec2& delta, const Vec2& position);
      bool handleKeyEvent(KeyCode key, bool pressed, const KeyModifiers& mods, bool isRepeat);
      bool handleTextInput(uint32_t codepoint);
      bool handleTextComposition(const char* text, int cursorPos, int selectionLength);
      
      // === 视口信息 ===
      void setViewportSize(const Vec2& size);
      Vec2 getViewportSize() const;
      void setDPIScale(float scale);
      float getDPIScale() const;
      
      // === 焦点管理 ===
      FocusManager& getFocusManager();
      const FocusManager& getFocusManager() const;
      
      // === 鼠标捕获 ===
      void captureMouse(UIComponent* component);
      void releaseMouse();
      UIComponent* getCapturedComponent() const;
      
      // === IME支持 ===
      Rect getInputMethodCursorRect() const;
      
      // === 内部使用 ===
      void addComponent(UIComponent* component);
      void removeComponent(UIComponent* component);
  
  private:
      struct Impl;
      std::unique_ptr<Impl> m_impl;
      
      UIContext(const UIContext&) = delete;
      UIContext& operator=(const UIContext&) = delete;
  };
  
  } // namespace YuchenUI
  ```

  #### 5.1.2 创建UIContext.cpp

  **文件**: `core/src/UIContext.cpp`

  ```cpp
  #include "YuchenUI/UIContext.h"
  #include "YuchenUI/IUIContent.h"
  #include "YuchenUI/focus/FocusManager.h"
  #include "YuchenUI/widgets/UIComponent.h"
  #include "YuchenUI/rendering/RenderList.h"
  #include <vector>
  #include <algorithm>
  #include <chrono>
  
  namespace YuchenUI {
  
  struct UIContext::Impl {
      std::unique_ptr<IUIContent> content;
      std::unique_ptr<FocusManager> focusManager;
      std::vector<UIComponent*> components;
      
      Vec2 viewportSize;
      float dpiScale;
      
      UIComponent* capturedComponent;
      
      // 时间管理
      std::chrono::time_point<std::chrono::high_resolution_clock> lastFrameTime;
      
      Impl()
          : content(nullptr)
          , focusManager(nullptr)
          , viewportSize(800, 600)
          , dpiScale(1.0f)
          , capturedComponent(nullptr)
          , lastFrameTime(std::chrono::high_resolution_clock::now())
      {}
  };
  
  UIContext::UIContext()
      : m_impl(std::make_unique<Impl>())
  {
      m_impl->focusManager = std::make_unique<FocusManager>(nullptr);
  }
  
  UIContext::~UIContext() = default;
  
  // === 内容管理 ===
  
  void UIContext::setContent(std::unique_ptr<IUIContent> content) {
      if (m_impl->content) {
          m_impl->content->onDestroy();
      }
      
      m_impl->content = std::move(content);
      
      if (m_impl->content) {
          Rect contentArea(0, 0, m_impl->viewportSize.x, m_impl->viewportSize.y);
          m_impl->content->onCreate(this, contentArea);
      }
  }
  
  IUIContent* UIContext::getContent() const {
      return m_impl->content.get();
  }
  
  // === 渲染循环 ===
  
  void UIContext::beginFrame() {
      // 计算deltaTime
      auto now = std::chrono::high_resolution_clock::now();
      float deltaTime = std::chrono::duration<float>(now - m_impl->lastFrameTime).count();
      m_impl->lastFrameTime = now;
      
      // 更新所有组件
      if (m_impl->content) {
          m_impl->content->onUpdate(deltaTime);
      }
  }
  
  void UIContext::render(RenderList& outCommandList) {
      if (m_impl->content) {
          m_impl->content->render(outCommandList);
      }
  }
  
  void UIContext::endFrame() {
      // 预留给未来的清理工作
  }
  
  // === 输入处理 ===
  
  bool UIContext::handleMouseMove(const Vec2& position) {
      // 优先发送到捕获的组件
      if (m_impl->capturedComponent) {
          return m_impl->capturedComponent->handleMouseMove(position);
      }
      
      // 否则发送到内容
      if (m_impl->content) {
          return m_impl->content->handleMouseMove(position);
      }
      
      return false;
  }
  
  bool UIContext::handleMouseClick(const Vec2& position, bool pressed) {
      // 优先发送到捕获的组件
      if (m_impl->capturedComponent) {
          return m_impl->capturedComponent->handleMouseClick(position, pressed);
      }
      
      // 否则发送到内容
      if (m_impl->content) {
          return m_impl->content->handleMouseClick(position, pressed);
      }
      
      return false;
  }
  
  bool UIContext::handleMouseWheel(const Vec2& delta, const Vec2& position) {
      if (m_impl->content) {
          return m_impl->content->handleMouseWheel(delta, position);
      }
      return false;
  }
  
  bool UIContext::handleKeyEvent(KeyCode key, bool pressed, const KeyModifiers& mods, bool isRepeat) {
      if (m_impl->content) {
          Event event;
          event.type = pressed ? EventType::KeyPressed : EventType::KeyReleased;
          event.key.key = key;
          event.key.modifiers = mods;
          event.key.isRepeat = isRepeat;
          
          return m_impl->content->handleKeyEvent(event);
      }
      return false;
  }
  
  bool UIContext::handleTextInput(uint32_t codepoint) {
      if (m_impl->content) {
          Event event;
          event.type = EventType::TextInput;
          event.textInput.codepoint = codepoint;
          
          return m_impl->content->handleTextInput(event);
      }
      return false;
  }
  
  bool UIContext::handleTextComposition(const char* text, int cursorPos, int selectionLength) {
      if (m_impl->content) {
          Event event;
          event.type = EventType::TextComposition;
          strncpy(event.textComposition.text, text, 255);
          event.textComposition.text[255] = '\0';
          event.textComposition.cursorPosition = cursorPos;
          event.textComposition.selectionLength = selectionLength;
          
          return m_impl->content->handleTextInput(event);
      }
      return false;
  }
  
  // === 视口信息 ===
  
  void UIContext::setViewportSize(const Vec2& size) {
      m_impl->viewportSize = size;
      
      if (m_impl->content) {
          Rect newArea(0, 0, size.x, size.y);
          m_impl->content->onResize(newArea);
      }
  }
  
  Vec2 UIContext::getViewportSize() const {
      return m_impl->viewportSize;
  }
  
  void UIContext::setDPIScale(float scale) {
      m_impl->dpiScale = scale;
  }
  
  float UIContext::getDPIScale() const {
      return m_impl->dpiScale;
  }
  
  // === 焦点管理 ===
  
  FocusManager& UIContext::getFocusManager() {
      return *m_impl->focusManager;
  }
  
  const FocusManager& UIContext::getFocusManager() const {
      return *m_impl->focusManager;
  }
  
  // === 鼠标捕获 ===
  
  void UIContext::captureMouse(UIComponent* component) {
      m_impl->capturedComponent = component;
  }
  
  void UIContext::releaseMouse() {
      m_impl->capturedComponent = nullptr;
  }
  
  UIComponent* UIContext::getCapturedComponent() const {
      return m_impl->capturedComponent;
  }
  
  // === IME支持 ===
  
  Rect UIContext::getInputMethodCursorRect() const {
      if (m_impl->content) {
          return m_impl->content->getInputMethodCursorRect();
      }
      return Rect();
  }
  
  // === 内部使用 ===
  
  void UIContext::addComponent(UIComponent* component) {
      auto it = std::find(m_impl->components.begin(), m_impl->components.end(), component);
      if (it == m_impl->components.end()) {
          m_impl->components.push_back(component);
      }
  }
  
  void UIContext::removeComponent(UIComponent* component) {
      auto it = std::find(m_impl->components.begin(), m_impl->components.end(), component);
      if (it != m_impl->components.end()) {
          m_impl->components.erase(it);
      }
  }
  
  } // namespace YuchenUI
  ```

  #### 5.1.3 创建IUIContent.h

  **文件**: `core/include/YuchenUI/IUIContent.h`

  ```cpp
  #pragma once
  
  #include "YuchenUI/core/Types.h"
  #include "YuchenUI/events/Event.h"
  #include <vector>
  #include <memory>
  
  namespace YuchenUI {
  
  class UIContext;
  class RenderList;
  class UIComponent;
  class FocusManager;
  
  class IUIContent {
  public:
      IUIContent();
      virtual ~IUIContent();
      
      // === 生命周期（无Window参数） ===
      virtual void onCreate(UIContext* context, const Rect& contentArea) = 0;
      virtual void onDestroy() {}
      virtual void onResize(const Rect& newArea) {}
      virtual void onUpdate(float deltaTime) {}
      virtual void render(RenderList& commandList) = 0;
      
      // === 事件处理 ===
      virtual bool handleMouseMove(const Vec2& position);
      virtual bool handleMouseClick(const Vec2& position, bool pressed);
      virtual bool handleMouseWheel(const Vec2& delta, const Vec2& position);
      virtual bool handleKeyEvent(const Event& event);
      virtual bool handleTextInput(const Event& event);
      
      // === IME支持 ===
      virtual Rect getInputMethodCursorRect() const;
      
      // === 组件管理（子类使用） ===
      void addComponent(UIComponent* component);
      void removeComponent(UIComponent* component);
      void clearComponents();
      
      // === 焦点管理 ===
      UIComponent* getFocusedComponent() const;
      void registerFocusableComponent(UIComponent* component);
      void unregisterFocusableComponent(UIComponent* component);
  
  protected:
      UIContext* m_context;
      Rect m_contentArea;
      std::vector<UIComponent*> m_components;
      
  private:
      bool handleMouseEvent(const Vec2& position, bool pressed, bool isMoveEvent);
  };
  
  } // namespace YuchenUI
  ```

  **文件**: `core/src/IUIContent.cpp`

  ```cpp
  #include "YuchenUI/IUIContent.h"
  #include "YuchenUI/UIContext.h"
  #include "YuchenUI/widgets/UIComponent.h"
  #include "YuchenUI/focus/FocusManager.h"
  #include "YuchenUI/rendering/RenderList.h"
  #include <algorithm>
  
  namespace YuchenUI {
  
  IUIContent::IUIContent()
      : m_context(nullptr)
      , m_contentArea()
      , m_components()
  {}
  
  IUIContent::~IUIContent() {
      clearComponents();
  }
  
  // === 事件处理 ===
  
  bool IUIContent::handleMouseEvent(const Vec2& position, bool pressed, bool isMoveEvent) {
      // 从后往前测试（最上层先响应）
      for (auto it = m_components.rbegin(); it != m_components.rend(); ++it) {
          UIComponent* component = *it;
          if (component && component->isVisible() && component->isEnabled()) {
              bool handled = isMoveEvent 
                  ? component->handleMouseMove(position)
                  : component->handleMouseClick(position, pressed);
              
              if (handled) {
                  if (!isMoveEvent && pressed) {
                      // 点击时尝试获得焦点
                      if (component->canAcceptFocus()) {
                          component->setFocus(FocusReason::MouseFocusReason);
                      }
                  }
                  return true;
              }
          }
      }
      
      // 没有组件处理，点击空白处清除焦点
      if (!isMoveEvent && !pressed && m_context) {
          m_context->getFocusManager().clearFocus();
      }
      
      return false;
  }
  
  bool IUIContent::handleMouseMove(const Vec2& position) {
      return handleMouseEvent(position, false, true);
  }
  
  bool IUIContent::handleMouseClick(const Vec2& position, bool pressed) {
      return handleMouseEvent(position, pressed, false);
  }
  
  bool IUIContent::handleMouseWheel(const Vec2& delta, const Vec2& position) {
      for (auto it = m_components.rbegin(); it != m_components.rend(); ++it) {
          UIComponent* component = *it;
          if (component && component->isVisible() && component->isEnabled()) {
              if (component->handleMouseWheel(delta, position)) {
                  return true;
              }
          }
      }
      return false;
  }
  
  bool IUIContent::handleKeyEvent(const Event& event) {
      if (!m_context) return false;
      
      auto* focused = m_context->getFocusManager().getFocusedComponent();
      if (focused && focused->isVisible() && focused->isEnabled()) {
          return focused->handleKeyPress(event);
      }
      
      return false;
  }
  
  bool IUIContent::handleTextInput(const Event& event) {
      if (!m_context) return false;
      
      auto* focused = m_context->getFocusManager().getFocusedComponent();
      if (!focused || !focused->isVisible() || !focused->isEnabled()) {
          return false;
      }
      
      if (event.type == EventType::TextComposition) {
          return focused->handleComposition(
              event.textComposition.text,
              event.textComposition.cursorPosition,
              event.textComposition.selectionLength
          );
      }
      
      return focused->handleTextInput(event.textInput.codepoint);
  }
  
  Rect IUIContent::getInputMethodCursorRect() const {
      if (!m_context) return Rect();
      
      auto* focused = m_context->getFocusManager().getFocusedComponent();
      if (!focused) return Rect();
      
      // 查询支持IME的组件
      IInputMethodSupport* inputSupport = dynamic_cast<IInputMethodSupport*>(focused);
      if (!inputSupport) return Rect();
      
      Rect localRect = inputSupport->getInputMethodCursorRect();
      return focused->mapToWindow(localRect);
  }
  
  // === 组件管理 ===
  
  void IUIContent::addComponent(UIComponent* component) {
      if (!component) return;
      
      if (m_context) {
          component->setOwnerContext(m_context);
          m_context->addComponent(component);
      }
      
      auto it = std::find(m_components.begin(), m_components.end(), component);
      if (it == m_components.end()) {
          m_components.push_back(component);
      }
  }
  
  void IUIContent::removeComponent(UIComponent* component) {
      if (!component) return;
      
      if (m_context) {
          unregisterFocusableComponent(component);
          m_context->removeComponent(component);
      }
      
      auto it = std::find(m_components.begin(), m_components.end(), component);
      if (it != m_components.end()) {
          m_components.erase(it);
      }
  }
  
  void IUIContent::clearComponents() {
      if (m_context) {
          m_context->getFocusManager().clearFocus();
      }
      m_components.clear();
  }
  
  UIComponent* IUIContent::getFocusedComponent() const {
      if (!m_context) return nullptr;
      return m_context->getFocusManager().getFocusedComponent();
  }
  
  void IUIContent::registerFocusableComponent(UIComponent* component) {
      if (m_context && component->getFocusPolicy() != FocusPolicy::NoFocus) {
          m_context->getFocusManager().registerComponent(component);
      }
  }
  
  void IUIContent::unregisterFocusableComponent(UIComponent* component) {
      if (m_context) {
          m_context->getFocusManager().unregisterComponent(component);
      }
  }
  
  } // namespace YuchenUI
  ```

  #### 5.1.4 创建IGraphicsBackend.h

  **文件**: `core/include/YuchenUI/rendering/IGraphicsBackend.h`

  ```cpp
  #pragma once
  
  #include "YuchenUI/core/Types.h"
  
  namespace YuchenUI {
  
  class RenderList;
  
  // 渲染器抽象接口（Core层定义，Platform层实现）
  class IGraphicsBackend {
  public:
      virtual ~IGraphicsBackend() = default;
      
      // === 帧管理 ===
      virtual void beginFrame() = 0;
      virtual void endFrame() = 0;
      
      // === 渲染 ===
      virtual void executeRenderCommands(const RenderList& commands) = 0;
      
      // === 纹理管理（给TextRenderer/TextureCache用） ===
      virtual void* createTexture2D(uint32_t width, uint32_t height, 
                                     TextureFormat format) = 0;
      virtual void updateTexture2D(void* texture, uint32_t x, uint32_t y,
                                   uint32_t width, uint32_t height,
                                   const void* data, size_t bytesPerRow) = 0;
      virtual void destroyTexture(void* texture) = 0;
      
      // === 视口信息 ===
      virtual Vec2 getRenderSize() const = 0;
      virtual float getDPIScale() const = 0;
  };
  
  } // namespace YuchenUI
  ```

  ------

  ### 5.2 Phase 2: Widget层重构

  #### 5.2.1 重构UIComponent

  **文件**: `core/include/YuchenUI/widgets/UIComponent.h`

  **改动清单：**

  ```cpp
  // 【删除】
  class BaseWindow;
  void setOwnerWindow(BaseWindow* window);
  BaseWindow* getOwnerWindow() const;
  BaseWindow* m_ownerWindow;
  
  // 【新增】
  class UIContext;
  void setOwnerContext(UIContext* context);
  UIContext* getOwnerContext() const;
  UIContext* m_ownerContext;
  
  // 【修改】captureMouse实现
  void captureMouse() {
      // 之前：m_ownerWindow->captureMouse(this);
      // 之后：m_ownerContext->captureMouse(this);
  }
  ```

  **完整代码：**

  ```cpp
  // core/include/YuchenUI/widgets/UIComponent.h
  #pragma once
  
  #include "YuchenUI/core/Types.h"
  #include "YuchenUI/events/Event.h"
  #include "YuchenUI/focus/FocusPolicy.h"
  
  namespace YuchenUI {
  
  class RenderList;
  class UIContext;  // 改：不再是BaseWindow
  class IUIContent;
  class Menu;
  
  class UIComponent {
  public:
      UIComponent();
      virtual ~UIComponent() = default;
      
      // === 渲染和事件 ===
      virtual void addDrawCommands(RenderList& commandList, const Vec2& offset = Vec2()) const = 0;
      virtual bool handleMouseMove(const Vec2& position, const Vec2& offset = Vec2()) = 0;
      virtual bool handleMouseClick(const Vec2& position, bool pressed, const Vec2& offset = Vec2()) = 0;
      virtual bool handleMouseWheel(const Vec2& delta, const Vec2& position, const Vec2& offset = Vec2()) { return false; }
      virtual bool handleKeyPress(const Event& event) { return false; }
      virtual bool handleTextInput(uint32_t codepoint) { return false; }
      virtual bool handleComposition(const char* text, int cursorPos, int selectionLength) { return false; }
      virtual void update(float deltaTime) {}
      
      virtual const Rect& getBounds() const = 0;
      Rect mapToWindow(const Rect& localRect) const;
      
      // === 可见性和启用 ===
      virtual bool isVisible() const { return m_isVisible; }
      virtual void setVisible(bool visible);
      virtual bool isEnabled() const { return m_isEnabled; }
      virtual void setEnabled(bool enabled);
      
      // === 所有者（改：UIContext替代BaseWindow） ===
      virtual void setOwnerContext(UIContext* context) { m_ownerContext = context; }
      UIContext* getOwnerContext() const { return m_ownerContext; }
      
      virtual void setOwnerContent(IUIContent* content) { m_ownerContent = content; }
      IUIContent* getOwnerContent() const { return m_ownerContent; }
      
      void setParent(UIComponent* parent) { m_parent = parent; }
      UIComponent* getParent() const { return m_parent; }
      
      // === 右键菜单 ===
      void setContextMenu(Menu* menu) { m_contextMenu = menu; }
      Menu* getContextMenu() const { return m_contextMenu; }
      bool hasContextMenu() const { return m_contextMenu != nullptr; }
      
      // === 焦点管理 ===
      void setFocusPolicy(FocusPolicy policy);
      FocusPolicy getFocusPolicy() const { return m_focusPolicy; }
      bool canAcceptFocus() const;
      bool hasFocus() const { return m_hasFocus; }
      void setFocus(FocusReason reason = FocusReason::OtherFocusReason);
      void clearFocus();
      
  protected:
      // 改：通过UIContext捕获
      void captureMouse();
      void releaseMouse();
      
      virtual void drawFocusIndicator(RenderList& commandList, const Vec2& offset) const;
      virtual CornerRadius getFocusIndicatorCornerRadius() const { return CornerRadius(); }
      
      virtual void focusInEvent(FocusReason reason) {}
      virtual void focusOutEvent(FocusReason reason) {}
      
      bool m_isVisible;
      bool m_isEnabled;
      UIContext* m_ownerContext;      // 改：替代m_ownerWindow
      IUIContent* m_ownerContent;
      UIComponent* m_parent;
      Menu* m_contextMenu;
  
  private:
      FocusPolicy m_focusPolicy;
      bool m_hasFocus;
      // ... 其他成员
      
      friend class FocusManager;
      friend class IUIContent;
  };
  
  } // namespace YuchenUI
  ```

  **文件**: `core/src/widgets/UIComponent.cpp`

  **改动要点：**

  ```cpp
  // 1. 包含头文件改动
  #include "YuchenUI/UIContext.h"  // 改：不再包含BaseWindow.h
  
  // 2. captureMouse实现
  void UIComponent::captureMouse() {
      if (m_ownerContext) {  // 改：不再是m_ownerWindow
          m_ownerContext->captureMouse(this);
      }
  }
  
  void UIComponent::releaseMouse() {
      if (m_ownerContext) {  // 改：不再是m_ownerWindow
          m_ownerContext->releaseMouse();
      }
  }
  
  // 3. setFocus实现
  void UIComponent::setFocus(FocusReason reason) {
      if (!m_ownerContext) return;
      m_ownerContext->getFocusManager().setFocus(this, reason);
  }
  
  // 4. mapToWindow保持不变（逻辑相同）
  Rect UIComponent::mapToWindow(const Rect& localRect) const {
      // 实现保持不变
  }
  ```

  #### 5.2.2 重构Widget

  **文件**: `core/include/YuchenUI/widgets/Widget.h`

  **改动清单：**

  ```cpp
  // 【修改】addChild方法中的设置顺序
  template<typename T, typename... Args>
  T* addChild(Args&&... args) {
      auto child = std::make_unique<T>(std::forward<Args>(args)...);
      T* ptr = child.get();
      
      // 设置关系
      ptr->setOwnerContext(m_ownerContext);  // 改：不再是m_ownerWindow
      ptr->setParent(this);
      
      m_children.push_back(std::move(child));
      
      // 设置内容和注册焦点
      ptr->setOwnerContent(m_ownerContent);
      if (m_ownerContent) {
          if (ptr->getFocusPolicy() != FocusPolicy::NoFocus) {
              m_ownerContent->registerFocusableComponent(ptr);
          }
      }
      
      return ptr;
  }
  
  // 【修改】setOwnerContext传递给子组件
  void setOwnerContext(UIContext* context) override {
      m_ownerContext = context;
      for (auto& child : m_children) {
          if (child) child->setOwnerContext(context);
      }
  }
  ```

  **完整代码见文件**：`core/src/widgets/Widget.cpp`

  改动较少，主要是将`BaseWindow`替换为`UIContext`。

  #### 5.2.3 批量修改其他Widget

  **需要修改的Widget列表：**

  - Button.h/cpp
  - TextLabel.h/cpp
  - TextBlock.h/cpp
  - Frame.h/cpp
  - GroupBox.h/cpp
  - Image.h/cpp
  - CheckBox.h/cpp
  - RadioButton.h/cpp
  - ComboBox.h/cpp
  - SpinBox.h/cpp
  - ScrollArea.h/cpp

  **统一改动模式：**

  1. 包含头文件：

  ```cpp
  // 删除
  #include "YuchenUI/windows/BaseWindow.h"
  
  // 改为（如果需要）
  #include "YuchenUI/UIContext.h"
  ```

  1. 构造函数无改动
  2. 成员函数中访问窗口的地方：

  ```cpp
  // 之前
  if (m_ownerWindow) {
      m_ownerWindow->enableTextInput();
  }
  
  // 之后
  // TextInput需要IME，但UIContext不提供enableTextInput
  // 改为：不在Widget中直接调用，由focusInEvent触发
  ```

  **特殊处理：TextInput**

  TextInput需要IME支持，改为：

  ```cpp
  // TextInput.cpp
  void TextInput::focusInEvent(FocusReason reason) {
      // 通过内容层请求文本输入
      if (m_ownerContent) {
          m_ownerContent->requestTextInput(true);
      }
  }
  
  void TextInput::focusOutEvent(FocusReason reason) {
      if (m_ownerContent) {
          m_ownerContent->requestTextInput(false);
      }
  }
  ```

  然后在IUIContent中：

  ```cpp
  // IUIContent.h
  virtual void requestTextInput(bool enable) {}  // 子类可选实现
  ```

  Platform层的实现会通过BaseWindow转发到平台窗口。

  #### 5.2.4 重构ComboBox菜单

  **文件**: `core/include/YuchenUI/widgets/ComboBox.h`

  **改动：**

  ```cpp
  // 【新增】菜单弹出处理器
  using MenuPopupHandler = std::function<void(const Vec2& screenPos, Menu* menu)>;
  
  void setMenuPopupHandler(MenuPopupHandler handler) {
      m_menuPopupHandler = handler;
  }
  
  private:
  MenuPopupHandler m_menuPopupHandler;
  ```

  **文件**: `core/src/widgets/ComboBox.cpp`

  ```cpp
  void ComboBox::openMenu() {
      buildMenu();
      
      // 计算屏幕坐标
      Rect bounds = getBounds();
      Vec2 screenPos = mapToWindow(Rect(bounds.x, bounds.y + bounds.height, 0, 0)).position;
      
      // 通过handler弹出（如果设置）
      if (m_menuPopupHandler && m_menu) {
          m_menuPopupHandler(screenPos, m_menu.get());
      } else {
          // 否则使用Menu自己的popup
          if (m_menu) {
              m_menu->popup(screenPos.x, screenPos.y);
          }
      }
  }
  ```

  ------

  ### 5.3 Phase 3: Platform层改造

  #### 5.3.1 重构BaseWindow

  **文件**: `platform/include/YuchenUI/windows/BaseWindow.h`

  **改动清单：**

  ```cpp
  // 【新增】
  #include "YuchenUI/UIContext.h"
  #include "YuchenUI/rendering/IGraphicsBackend.h"
  
  // 【删除】
  #include "YuchenUI/rendering/GraphicsContext.h"
  #include "YuchenUI/windows/IWindowContent.h"
  
  // 【改】成员变量
  UIContext m_uiContext;                          // 新增：UI上下文
  std::unique_ptr<IGraphicsBackend> m_backend;    // 改：抽象接口
  
  // 【删】
  GraphicsContext* m_renderer;
  std::unique_ptr<IWindowContent> m_content;
  
  // 【改】setContent方法
  template<typename ContentType, typename... Args>
  void setContent(Args&&... args) {
      auto content = std::make_unique<ContentType>(std::forward<Args>(args)...);
      m_uiContext.setContent(std::move(content));
  }
  ```

  **完整代码：**

  ```cpp
  // platform/include/YuchenUI/windows/BaseWindow.h
  #pragma once
  
  #include "YuchenUI/windows/Window.h"
  #include "YuchenUI/core/Types.h"
  #include "YuchenUI/UIContext.h"                    // 新增
  #include "YuchenUI/rendering/IGraphicsBackend.h"   // 新增
  #include <memory>
  #include <functional>
  
  namespace YuchenUI {
  
  class EventManager;
  class WindowImpl;
  class IUIContent;
  
  using DialogResultCallback = std::function<void(WindowContentResult result, void* userData)>;
  
  enum class WindowState {
      Uninitialized,
      Created,
      RendererReady,
      Shown
  };
  
  class BaseWindow : public Window {
  public:
      explicit BaseWindow(WindowType type = WindowType::Main);
      virtual ~BaseWindow();
      
      // === 窗口创建 ===
      bool create(int width, int height, const char* title, Window* parent = nullptr) override;
      void destroy() override;
      
      // === 内容设置 ===
      template<typename ContentType, typename... Args>
      void setContent(Args&&... args) {
          auto content = std::make_unique<ContentType>(std::forward<Args>(args)...);
          m_uiContext.setContent(std::move(content));
          
          // 设置ComboBox的菜单处理器
          setupMenuHandlers();
      }
      
      // === 渲染 ===
      void renderContent();
      
      // === 窗口显示 ===
      void show();
      void hide();
      bool isVisible() const;
      void showModal();
      void closeModal();
      void closeWithResult(WindowContentResult result);
      void setResultCallback(DialogResultCallback callback);
      
      // === 事件处理 ===
      void handleNativeEvent(void* event);
      void onResize(int width, int height);
      
      // === 访问器 ===
      bool shouldClose() override;
      Vec2 getSize() const override;
      Vec2 getMousePosition() const override;
      bool isMousePressed() const override;
      void* getNativeWindowHandle() const override;
      Vec2 getWindowPosition() const override;
      Vec2 mapToScreen(const Vec2& windowPos) const override;
      
      // === IME支持 ===
      void enableTextInput() override;
      void disableTextInput() override;
      void setIMEEnabled(bool enabled) override;
      void handleMarkedText(const char* text, int cursorPos, int selectionLength);
      void handleUnmarkText();
      Rect getInputMethodCursorRect() const;
      
      // === 访问UIContext（给子类用） ===
      UIContext& getUIContext() { return m_uiContext; }
      const UIContext& getUIContext() const { return m_uiContext; }
  
  private:
      bool initializeRenderer();
      void setupMenuHandlers();
      
      std::unique_ptr<WindowImpl> m_impl;
      std::unique_ptr<IGraphicsBackend> m_backend;    // 改：抽象后端
      UIContext m_uiContext;                          // 新增：UI上下文
      std::unique_ptr<EventManager> m_eventManager;
      
      Window* m_parentWindow;
      WindowType m_windowType;
      WindowState m_state;
      bool m_shouldClose;
      int m_width;
      int m_height;
      float m_dpiScale;
      DialogResultCallback m_resultCallback;
      bool m_isModal;
  };
  
  } // namespace YuchenUI
  ```

  **文件**: `platform/src/windows/BaseWindow.cpp`

  **关键改动：**

  ```cpp
  #include "YuchenUI/windows/BaseWindow.h"
  #include "YuchenUI/IUIContent.h"               // 新增
  #include "YuchenUI/platform/PlatformBackend.h"
  #include "YuchenUI/platform/WindowImpl.h"
  #include "YuchenUI/platform/EventManager.h"
  #include "YuchenUI/rendering/RenderList.h"
  #include "YuchenUI/theme/ThemeManager.h"
  #include "YuchenUI/widgets/ComboBox.h"  // 为了设置菜单handler
  #include "YuchenUI/menu/Menu.h"
  
  // 构造函数
  BaseWindow::BaseWindow(WindowType type)
      : m_impl(nullptr)
      , m_backend(nullptr)          // 改
      , m_uiContext()                // 新增
      , m_eventManager(nullptr)
      , m_parentWindow(nullptr)
      , m_windowType(type)
      , m_state(WindowState::Uninitialized)
      , m_shouldClose(false)
      , m_width(0)
      , m_height(0)
      , m_dpiScale(1.0f)
      , m_resultCallback(nullptr)
      , m_isModal(false)
  {
      m_impl.reset(WindowImplFactory::create());
  }
  
  // create方法
  bool BaseWindow::create(int width, int height, const char* title, Window* parent) {
      m_parentWindow = parent;
      m_width = width;
      m_height = height;
      
      WindowConfig config(width, height, title, parent, m_windowType);
      
      if (!m_impl->create(config)) {
          return false;
      }
      m_impl->setBaseWindow(this);
      
      // 检测DPI
      m_dpiScale = m_impl->getDpiScale();
      m_uiContext.setDPIScale(m_dpiScale);
      m_uiContext.setViewportSize(Vec2(width, height));
      
      // 初始化渲染器
      if (!initializeRenderer()) {
          return false;
      }
      
      // 创建事件管理器
      m_eventManager.reset(PlatformBackend::createEventManager(m_impl->getNativeHandle()));
      if (!m_eventManager->initialize()) {
          return false;
      }
      
      m_eventManager->setEventCallback([this](const Event& event) {
          this->handleEvent(event);
      });
      
      m_state = WindowState::Created;
      m_state = WindowState::RendererReady;
      
      if (m_windowType == WindowType::Main) {
          show();
      }
      
      return true;
  }
  
  // initializeRenderer改动
  bool BaseWindow::initializeRenderer() {
      // 创建平台后端（返回IGraphicsBackend*）
      m_backend.reset(PlatformBackend::createGraphicsBackend());
      
      if (!m_backend) {
          return false;
      }
      
      // 初始化（平台相关）
      // MetalRenderer在自己的构造函数中已设置surface等
      
      return true;
  }
  
  // renderContent改动
  void BaseWindow::renderContent() {
      if (!m_backend || m_state < WindowState::Created) {
          return;
      }
      
      m_backend->beginFrame();
      
      RenderList commandList;
      Vec4 bgColor = ThemeManager::getInstance().getCurrentStyle()
          ->getWindowBackground(m_windowType);
      commandList.clear(bgColor);
      
      m_uiContext.beginFrame();
      m_uiContext.render(commandList);
      m_uiContext.endFrame();
      
      m_backend->executeRenderCommands(commandList);
      m_backend->endFrame();
  }
  
  // handleEvent改动
  void BaseWindow::handleEvent(const Event& event) {
      bool handled = false;
      
      switch (event.type) {
          case EventType::MouseButtonPressed:
          case EventType::MouseButtonReleased:
              handled = m_uiContext.handleMouseClick(
                  event.mouseButton.position,
                  event.type == EventType::MouseButtonPressed
              );
              break;
              
          case EventType::MouseMoved:
              handled = m_uiContext.handleMouseMove(event.mouseMove.position);
              break;
              
          case EventType::MouseScrolled:
              handled = m_uiContext.handleMouseWheel(
                  event.mouseScroll.delta,
                  event.mouseScroll.position
              );
              break;
              
          case EventType::KeyPressed:
          case EventType::KeyReleased:
              handled = m_uiContext.handleKeyEvent(
                  event.key.key,
                  event.type == EventType::KeyPressed,
                  event.key.modifiers,
                  event.key.isRepeat
              );
              break;
              
          case EventType::TextInput:
              handled = m_uiContext.handleTextInput(event.textInput.codepoint);
              break;
              
          case EventType::TextComposition:
              handled = m_uiContext.handleTextComposition(
                  event.textComposition.text,
                  event.textComposition.cursorPosition,
                  event.textComposition.selectionLength
              );
              break;
              
          case EventType::WindowClosed:
              m_shouldClose = true;
              break;
              
          case EventType::WindowResized:
              onResize((int)event.window.size.x, (int)event.window.size.y);
              break;
              
          default:
              break;
      }
  }
  
  // onResize改动
  void BaseWindow::onResize(int width, int height) {
      if (width != m_width || height != m_height) {
          m_width = width;
          m_height = height;
          m_uiContext.setViewportSize(Vec2(width, height));
      }
  }
  
  // IME支持
  Rect BaseWindow::getInputMethodCursorRect() const {
      return m_uiContext.getInputMethodCursorRect();
  }
  
  // 菜单处理器设置（新增）
  void BaseWindow::setupMenuHandlers() {
      auto* content = m_uiContext.getContent();
      if (!content) return;
      
      // 遍历内容中的所有组件，找到ComboBox设置handler
      // 这里简化处理，实际可能需要递归遍历
      // （或者在ComboBox构造时自动从context获取handler）
  }
  ```

  #### 5.3.2 重构MetalRenderer

  **文件**: `platform/src/macos/MetalRenderer.h`

  **改动清单：**

  ```cpp
  // 【改】继承接口
  class MetalRenderer : public IGraphicsBackend {  // 改：不再继承GraphicsContext
  public:
      MetalRenderer();
      ~MetalRenderer() override;
      
      // === 实现IGraphicsBackend接口 ===
      void beginFrame() override;
      void endFrame() override;
      void executeRenderCommands(const RenderList& commands) override;
      
      void* createTexture2D(uint32_t width, uint32_t height, TextureFormat format) override;
      void updateTexture2D(void* texture, uint32_t x, uint32_t y,
                          uint32_t width, uint32_t height,
                          const void* data, size_t bytesPerRow) override;
      void destroyTexture(void* texture) override;
      
      Vec2 getRenderSize() const override;
      float getDPIScale() const override;
      
      // === 平台特定（不在接口中） ===
      bool initialize(void* metalLayer, int width, int height, float dpiScale);
      void resize(int width, int height);
  
  private:
      // Metal相关成员保持不变
  };
  ```

  **文件**: `platform/src/macos/MetalRenderer.mm`

  **改动要点：**

  1. 删除`setSurface()`和`setSharedDevice()`方法
  2. 改为在`initialize()`中直接接收参数
  3. 其他实现基本保持不变

  ```cpp
  bool MetalRenderer::initialize(void* metalLayer, int width, int height, float dpiScale) {
      m_metalLayer = (__bridge CAMetalLayer*)metalLayer;
      m_width = width;
      m_height = height;
      m_dpiScale = dpiScale;
      
      // 配置Metal layer
      m_metalLayer.device = m_device;
      m_metalLayer.pixelFormat = MTLPixelFormatBGRA8Unorm;
      m_metalLayer.drawableSize = CGSizeMake(width * dpiScale, height * dpiScale);
      
      // 其他初始化...
      
      m_isInitialized = true;
      return true;
  }
  ```

  #### 5.3.3 更新PlatformBackend

  **文件**: `platform/include/YuchenUI/platform/PlatformBackend.h`

  ```cpp
  #pragma once
  
  namespace YuchenUI {
  
  class IGraphicsBackend;  // 改：返回抽象接口
  class EventManager;
  
  class PlatformBackend {
  public:
      // 改：返回IGraphicsBackend*
      static IGraphicsBackend* createGraphicsBackend();
      
      static EventManager* createEventManager(void* nativeWindow);
      
      // 共享设备相关保持不变（可选）
      static void* createSharedDevice();
      static void destroySharedDevice(void* device);
  };
  
  } // namespace YuchenUI
  ```

  **文件**: `platform/src/macos/PlatformBackend.mm`

  ```cpp
  #include "YuchenUI/platform/PlatformBackend.h"
  #include "MetalRenderer.h"
  #include "MacEventManager.h"
  
  namespace YuchenUI {
  
  IGraphicsBackend* PlatformBackend::createGraphicsBackend() {
      return new MetalRenderer();  // 返回实现类指针
  }
  
  EventManager* PlatformBackend::createEventManager(void* nativeWindow) {
      return new MacEventManager((__bridge NSWindow*)nativeWindow);
  }
  
  // ... 其他方法保持不变
  }
  ```

  #### 5.3.4 简化EventManager

  **文件**: `platform/include/YuchenUI/events/EventManager.h`

  **改动：去掉队列和回调（可选优化）**

  如果想彻底简化EventManager为纯转换器：

  ```cpp
  class EventManager {
  public:
      virtual ~EventManager() = default;
      
      virtual bool initialize() = 0;
      virtual void destroy() = 0;
      
      // 纯转换方法（新增）
      virtual Event convertNativeEvent(void* nativeEvent) = 0;
      
      // 保留的查询方法
      virtual bool isKeyPressed(KeyCode key) const = 0;
      virtual bool isMouseButtonPressed(MouseButton button) const = 0;
      virtual Vec2 getMousePosition() const = 0;
      virtual KeyModifiers getCurrentModifiers() const = 0;
  };
  ```

  但为了简化工作，**建议保持EventManager不变**，只是BaseWindow不再使用队列，而是直接在回调中转发。

  ------

  ### 5.4 Phase 4: CMake配置

  #### 5.4.1 Core层CMakeLists.txt

  **文件**: `core/CMakeLists.txt`

  ```cmake
  cmake_minimum_required(VERSION 3.15)
  project(YuchenUI_Core)
  
  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  
  # 源文件
  set(CORE_SOURCES
      # 核心
      src/UIContext.cpp
      src/IUIContent.cpp
      
      # Widget
      src/widgets/UIComponent.cpp
      src/widgets/Widget.cpp
      src/widgets/Button.cpp
      src/widgets/TextLabel.cpp
      src/widgets/TextBlock.cpp
      src/widgets/Frame.cpp
      src/widgets/GroupBox.cpp
      src/widgets/Image.cpp
      src/widgets/CheckBox.cpp
      src/widgets/RadioButton.cpp
      src/widgets/ComboBox.cpp
      src/widgets/SpinBox.cpp
      src/widgets/ScrollArea.cpp
      src/widgets/TextInput.cpp
      
      # 焦点
      src/focus/FocusManager.cpp
      
      # 菜单
      src/menu/Menu.cpp
      src/menu/MenuItem.cpp
      
      # 渲染
      src/rendering/RenderList.cpp
      
      # 文本
      src/text/Font.cpp
      src/text/FontManager.cpp
      src/text/TextRenderer.cpp
      src/text/GlyphCache.cpp
      src/text/TextUtils.cpp
      
      # 主题
      src/theme/Theme.cpp
      src/theme/ThemeManager.cpp
      
      # 图像
      src/image/ImageDecoder.cpp
      src/image/TextureCache.cpp
  )
  
  # 创建库
  add_library(YuchenUI_Core STATIC ${CORE_SOURCES})
  
  # 头文件路径
  target_include_directories(YuchenUI_Core PUBLIC
      ${CMAKE_CURRENT_SOURCE_DIR}/include
  )
  
  # 依赖：FreeType
  find_package(Freetype REQUIRED)
  target_link_libraries(YuchenUI_Core PUBLIC Freetype::Freetype)
  
  # 依赖：HarfBuzz
  find_package(harfbuzz REQUIRED)
  target_link_libraries(YuchenUI_Core PUBLIC harfbuzz::harfbuzz)
  
  # 编译选项
  if(MSVC)
      target_compile_options(YuchenUI_Core PRIVATE /W4)
  else()
      target_compile_options(YuchenUI_Core PRIVATE -Wall -Wextra)
  endif()
  ```

  #### 5.4.2 Platform层CMakeLists.txt

  **文件**: `platform/CMakeLists.txt`

  ```cmake
  cmake_minimum_required(VERSION 3.15)
  project(YuchenUI_Platform)
  
  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  
  # 平台检测
  if(APPLE)
      set(PLATFORM_SOURCES
          src/windows/BaseWindow.cpp
          src/windows/WindowManager.cpp
          src/macos/MacOSWindowImpl.mm
          src/macos/MacEventManager.mm
          src/macos/MetalRenderer.mm
          src/macos/MacMenuImpl.mm
          src/macos/PlatformBackend.mm
      )
      
      set(PLATFORM_FRAMEWORKS
          "-framework Cocoa"
          "-framework Metal"
          "-framework MetalKit"
          "-framework QuartzCore"
      )
  elseif(WIN32)
      # Windows平台源文件（待实现）
      set(PLATFORM_SOURCES
          src/windows/BaseWindow.cpp
          src/windows/WindowManager.cpp
          # ... Win32实现
      )
  endif()
  
  # 创建库
  add_library(YuchenUI_Platform STATIC ${PLATFORM_SOURCES})
  
  # 依赖Core层
  target_link_libraries(YuchenUI_Platform PUBLIC YuchenUI_Core)
  
  # 头文件路径
  target_include_directories(YuchenUI_Platform PUBLIC
      ${CMAKE_CURRENT_SOURCE_DIR}/include
  )
  
  # 平台框架
  if(APPLE)
      target_link_libraries(YuchenUI_Platform PUBLIC ${PLATFORM_FRAMEWORKS})
  endif()
  
  # 编译选项
  if(APPLE)
      target_compile_options(YuchenUI_Platform PRIVATE
          -Wall -Wextra
          -fobjc-arc  # ARC支持
      )
  endif()
  ```

  #### 5.4.3 根CMakeLists.txt

  **文件**: `CMakeLists.txt`

  ```cmake
  cmake_minimum_required(VERSION 3.15)
  project(YuchenUI VERSION 1.0.0)
  
  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  
  # 选项
  option(YUCHEN_BUILD_CORE_ONLY "Build only the Core library" OFF)
  option(YUCHEN_BUILD_PLATFORM "Build Platform layer" ON)
  option(YUCHEN_BUILD_EXAMPLES "Build examples" ON)
  
  # Core层（必须）
  add_subdirectory(core)
  
  # Platform层（可选）
  if(YUCHEN_BUILD_PLATFORM)
      add_subdirectory(platform)
  endif()
  
  # 示例
  if(YUCHEN_BUILD_EXAMPLES)
      add_subdirectory(examples)
  endif()
  
  # 创建总库（兼容性）
  add_library(YuchenUI INTERFACE)
  target_link_libraries(YuchenUI INTERFACE YuchenUI_Core)
  
  if(YUCHEN_BUILD_PLATFORM)
      target_link_libraries(YuchenUI INTERFACE YuchenUI_Platform)
  endif()
  ```

  ------

  ## 6. 测试验证

  ### 6.1 Core层独立编译测试

  ```bash
  # 验证Core可以独立编译
  cd core
  mkdir build && cd build
  cmake .. -DCMAKE_BUILD_TYPE=Debug
  make
  
  # 应该成功编译，不报错
  ```

  ### 6.2 依赖检查

  ```bash
  # 检查Core层是否包含Platform头文件
  cd core/include
  grep -r "windows/" . && echo "❌ Core依赖Platform！" || echo "✅ Core独立"
  grep -r "platform/" . && echo "❌ Core依赖Platform！" || echo "✅ Core独立"
  
  # 检查Platform层是否正确依赖Core
  cd platform/src
  grep -r "YuchenUI/UIContext.h" . && echo "✅ Platform使用Core" || echo "❌ Platform未使用Core"
  ```

  ### 6.3 功能测试

  #### 测试1：纯UI模式（GLFW）

  ```cpp
  // examples/glfw_pure/main.cpp
  #include <YuchenUI/UIContext.h>
  #include <YuchenUI/IUIContent.h>
  #include <YuchenUI/widgets/Button.h>
  #include <GLFW/glfw3.h>
  
  class TestContent : public YuchenUI::IUIContent {
  public:
      void onCreate(YuchenUI::UIContext* context, const YuchenUI::Rect& area) override {
          m_context = context;
          m_contentArea = area;
          
          // 创建按钮
          auto* button = new YuchenUI::Button(YuchenUI::Rect(10, 10, 100, 30));
          button->setText("Click Me");
          button->setOwnerContext(context);
          addComponent(button);
      }
      
      void render(YuchenUI::RenderList& commandList) override {
          commandList.clear(YuchenUI::Colors::DEFAULT_CLEAR_COLOR);
          
          for (auto* comp : m_components) {
              if (comp && comp->isVisible()) {
                  comp->addDrawCommands(commandList);
              }
          }
      }
  };
  
  int main() {
      glfwInit();
      GLFWwindow* window = glfwCreateWindow(800, 600, "Pure UI Test", nullptr, nullptr);
      
      YuchenUI::UIContext uiContext;
      uiContext.setViewportSize(YuchenUI::Vec2(800, 600));
      uiContext.setContent(std::make_unique<TestContent>());
      
      while (!glfwWindowShouldClose(window)) {
          uiContext.beginFrame();
          
          YuchenUI::RenderList commandList;
          uiContext.render(commandList);
          
          // TODO: 执行OpenGL渲染
          
          uiContext.endFrame();
          
          glfwSwapBuffers(window);
          glfwPollEvents();
      }
      
      glfwTerminate();
      return 0;
  }
  ```

  #### 测试2：Platform模式

  ```cpp
  // examples/native_window/main.cpp
  #include <YuchenUI/windows/WindowManager.h>
  #include <YuchenUI/windows/BaseWindow.h>
  #include <YuchenUI/IUIContent.h>
  #include <YuchenUI/widgets/Button.h>
  
  class TestContent : public YuchenUI::IUIContent {
  public:
      void onCreate(YuchenUI::UIContext* context, const YuchenUI::Rect& area) override {
          m_context = context;
          
          auto* button = new YuchenUI::Button(YuchenUI::Rect(10, 10, 150, 40));
          button->setText("Native Window Test");
          button->setOwnerContext(context);
          addComponent(button);
      }
      
      void render(YuchenUI::RenderList& commandList) override {
          for (auto* comp : m_components) {
              if (comp && comp->isVisible()) {
                  comp->addDrawCommands(commandList);
              }
          }
      }
  };
  
  int main() {
      YuchenUI::WindowManager::getInstance().initialize();
      
      auto* mainWindow = YuchenUI::WindowManager::getInstance()
          .createMainWindow<TestContent>(800, 600, "Platform Test");
      
      mainWindow->show();
      
      YuchenUI::WindowManager::getInstance().run();
      return 0;
  }
  ```

  ### 6.4 回归测试清单

  | 功能          | Core测试       | Platform测试 |
  | ------------- | -------------- | ------------ |
  | Button点击    | ✅              | ✅            |
  | TextInput输入 | ✅              | ✅            |
  | 焦点Tab切换   | ✅              | ✅            |
  | 鼠标拖动      | ✅              | ✅            |
  | 滚动区域      | ✅              | ✅            |
  | ComboBox下拉  | ⚠️需注入handler | ✅            |
  | 中文输入(IME) | N/A            | ✅            |
  | 弹出对话框    | N/A            | ✅            |

  ------

  ## 7. 工作分配建议

  ### 7.1 并行任务分配（3人团队）

  #### **开发者A：Core层基础**

  - **Day 1-2**: 创建UIContext/IUIContent/IGraphicsBackend
  - **Day 3**: 重构UIComponent/Widget
  - **Day 4-5**: 批量修改所有Widget
  - **风险**: UIContext设计不当会影响后续

  #### **开发者B：Platform层改造**

  - **Day 1**: 等待A完成UIContext
  - **Day 2-3**: 重构BaseWindow
  - **Day 4**: 重构MetalRenderer
  - **Day 5**: 测试Platform模式
  - **依赖**: 需要A的UIContext完成

  #### **开发者C：测试和文档**

  - **Day 1-2**: 编写Core层单元测试
  - **Day 3**: 编写GLFW示例
  - **Day 4**: 编写Platform测试
  - **Day 5**: 回归测试和问题修复

  ### 7.2 串行任务（1人团队）

  | 阶段   | 任务         | 时间 |
  | ------ | ------------ | ---- |
  | Week 1 | Core基础     | 5天  |
  | Week 2 | Widget重构   | 3天  |
  |        | Platform改造 | 2天  |
  | Week 3 | 测试验证     | 3天  |
  |        | 问题修复     | 2天  |

  ### 7.3 里程碑检查点

  **Checkpoint 1 (Day 2)**: Core基础完成

  - ✅ UIContext可编译
  - ✅ IUIContent定义明确
  - ✅ IGraphicsBackend接口清晰

  **Checkpoint 2 (Day 5)**: Widget重构完成

  - ✅ 所有Widget编译通过
  - ✅ Core层独立编译成功
  - ✅ 无Platform依赖

  **Checkpoint 3 (Day 8)**: Platform改造完成

  - ✅ BaseWindow编译通过
  - ✅ MetalRenderer实现IGraphicsBackend
  - ✅ Platform测试通过

  **Checkpoint 4 (Day 10)**: 测试完成

  - ✅ 所有回归测试通过
  - ✅ GLFW示例可运行
  - ✅ Platform模式可运行

  ------

  ## 8. 风险和应对

  ### 8.1 高风险项

  | 风险              | 概率 | 影响 | 缓解措施                      |
  | ----------------- | ---- | ---- | ----------------------------- |
  | UIContext设计缺陷 | 高   | 严重 | 提前设计评审，写原型验证      |
  | 循环依赖          | 中   | 严重 | 严格检查include，使用前向声明 |
  | 焦点系统破坏      | 中   | 中等 | 单独测试焦点功能              |
  | IME输入失效       | 低   | 中等 | macOS测试中文输入             |

  ### 8.2 应对策略

  1. **设计评审**：Phase 1开始前，团队评审UIContext设计
  2. **增量测试**：每个Phase结束后编译测试
  3. **Git分支**：使用`feature/core-refactor`分支，保留主分支
  4. **代码审查**：关键文件由两人review

  ------

  ## 9. 附录

  ### 9.1 快速参考

  **Core层关键类：**

  - `UIContext` - 核心入口
  - `IUIContent` - 内容接口
  - `IGraphicsBackend` - 渲染抽象
  - `UIComponent` - 组件基类

  **Platform层关键类：**

  - `BaseWindow` - 窗口托管UIContext
  - `MetalRenderer` - 实现IGraphicsBackend
  - `WindowManager` - 窗口管理器

  **依赖规则：**

  ```
  Platform → Core  ✅
  Core → Platform  ❌
  ```

  ### 9.2 常见问题

  **Q: TextInput如何触发IME？** A: 通过focusInEvent回调，调用IUIContent::requestTextInput()，由Platform层处理。

  **Q: ComboBox如何弹出菜单？** A: 注入MenuPopupHandler，由Platform层实现原生弹出。

  **Q: 如何确保Core不依赖Platform？** A: 使用抽象接口（IGraphicsBackend），定义在Core，实现在Platform。

  ------

  **文档结束**
