- # YuchenUI æ¶æ„é‡æ„è¯¦ç»†æ–‡æ¡£

  **æ–‡æ¡£ç‰ˆæœ¬**: 1.0
   **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
   **ç›®æ ‡**: å°†YuchenUIä»çª—å£æ¡†æ¶é‡æ„ä¸ºçº¯UIåº“ + å¯é€‰å¹³å°å±‚

  ------

  ## ğŸ“‹ ç›®å½•

  1. [é‡æ„ç›®æ ‡ä¸åŸåˆ™](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#1-é‡æ„ç›®æ ‡ä¸åŸåˆ™)
  2. [æ–°æ¶æ„è®¾è®¡](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#2-æ–°æ¶æ„è®¾è®¡)
  3. [å…³é”®è®¾è®¡å†³ç­–](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#3-å…³é”®è®¾è®¡å†³ç­–)
  4. [æ–‡ä»¶æ¸…å•ä¸æ”¹åŠ¨](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#4-æ–‡ä»¶æ¸…å•ä¸æ”¹åŠ¨)
  5. [è¯¦ç»†é‡æ„æŒ‡å—](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#5-è¯¦ç»†é‡æ„æŒ‡å—)
  6. [æµ‹è¯•éªŒè¯](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#6-æµ‹è¯•éªŒè¯)
  7. [å·¥ä½œåˆ†é…å»ºè®®](https://35467123.sdppt.com/chat/0e6a2931-659a-415c-8097-f4eef8681760#7-å·¥ä½œåˆ†é…å»ºè®®)

  ------

  ## 1. é‡æ„ç›®æ ‡ä¸åŸåˆ™

  ### 1.1 ç›®æ ‡

  å°†YuchenUIæ‹†åˆ†ä¸ºä¸¤ä¸ªç‹¬ç«‹çš„åº“ï¼š

  1. **YuchenUI Core** - çº¯UIæ¸²æŸ“åº“
     - ä¸ä¾èµ–ä»»ä½•çª—å£ç³»ç»Ÿ
     - å¯åµŒå…¥GLFWã€VST3ã€Webã€æ¸¸æˆå¼•æ“ç­‰
     - å®Œæ•´çš„Widgetç³»ç»Ÿã€ä¸»é¢˜ã€ç„¦ç‚¹ç®¡ç†
  2. **YuchenUI Platform** - å¹³å°çª—å£å±‚ï¼ˆå¯é€‰ï¼‰
     - æä¾›åŸç”Ÿçª—å£ç®¡ç†
     - å°è£…æ“ä½œç³»ç»ŸAPIï¼ˆCocoa/Win32ï¼‰
     - ä¾èµ–Coreå±‚

  ### 1.2 æ ¸å¿ƒåŸåˆ™

  ```
  âœ… å•å‘ä¾èµ–ï¼šPlatform â†’ Coreï¼ŒCoreä¸ä¾èµ–Platform
  âœ… æ¥å£æŠ½è±¡ï¼šCoreå®šä¹‰æ¥å£ï¼ŒPlatformæä¾›å®ç°
  âœ… çº¯å‡€Coreï¼šCoreå±‚é›¶çª—å£ç³»ç»Ÿä¾èµ–
  âœ… ç‹¬ç«‹ç¼–è¯‘ï¼šCoreå¯å•ç‹¬ç¼–è¯‘æˆåº“
  ```

  ------

  ## 2. æ–°æ¶æ„è®¾è®¡

  ### 2.1 åˆ†å±‚æ¶æ„

  ```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  ç”¨æˆ·åº”ç”¨å±‚                                  â”‚
  â”‚  â”œâ”€ çº¯UIæ¨¡å¼ï¼šUIContext + è‡ªå®šä¹‰çª—å£         â”‚
  â”‚  â””â”€ å¹³å°æ¨¡å¼ï¼šWindowManager + BaseWindow    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  YuchenUI Platform (å¯é€‰)                    â”‚
  â”‚  â”œâ”€ WindowManager                           â”‚
  â”‚  â”œâ”€ BaseWindow                              â”‚
  â”‚  â”œâ”€ WindowImpl (macOS/Windows)             â”‚
  â”‚  â”œâ”€ MetalRenderer (å®ç°IGraphicsBackend)    â”‚
  â”‚  â””â”€ MacEventManager                         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“ ä¾èµ–
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  YuchenUI Core (çº¯UI)                        â”‚
  â”‚  â”œâ”€ UIContext (æ–°æ ¸å¿ƒç±»)                     â”‚
  â”‚  â”œâ”€ IUIContent (æ›¿ä»£IWindowContent)         â”‚
  â”‚  â”œâ”€ Widgetç³»ç»Ÿ (Button/TextInputç­‰)         â”‚
  â”‚  â”œâ”€ IGraphicsBackend (æŠ½è±¡æ¥å£)             â”‚
  â”‚  â”œâ”€ RenderList                              â”‚
  â”‚  â”œâ”€ TextRenderer / FontManager              â”‚
  â”‚  â”œâ”€ ThemeManager                            â”‚
  â”‚  â””â”€ FocusManager                            â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ```

  ### 2.2 æ•°æ®æµ

  **è¾“å…¥æµï¼š**

  ```
  å¹³å°äº‹ä»¶ â†’ EventManager(è½¬æ¢) â†’ UIContext â†’ IUIContent â†’ Widgetæ ‘
  ```

  **æ¸²æŸ“æµï¼š**

  ```
  Widgetæ ‘ â†’ RenderList â†’ IGraphicsBackend â†’ GPU
  ```

  ------

  ## 3. å…³é”®è®¾è®¡å†³ç­–

  ### 3.1 UIContextèŒè´£

  UIContextæ˜¯Coreå±‚çš„æ ¸å¿ƒå…¥å£ï¼Œè´Ÿè´£ï¼š

  | èŒè´£     | è¯´æ˜                          |
  | -------- | ----------------------------- |
  | å†…å®¹ç®¡ç† | æŒæœ‰IUIContentå®ä¾‹            |
  | è¾“å…¥è·¯ç”± | è½¬å‘é¼ æ ‡/é”®ç›˜/æ–‡æœ¬è¾“å…¥åˆ°ç»„ä»¶  |
  | æ¸²æŸ“åè°ƒ | è°ƒç”¨IUIContentç”ŸæˆRenderList  |
  | ç„¦ç‚¹ç®¡ç† | æŒæœ‰FocusManagerï¼Œå¤„ç†Tabå¯¼èˆª |
  | é¼ æ ‡æ•è· | ç®¡ç†å½“å‰æ•è·è¾“å…¥çš„ç»„ä»¶        |
  | è§†å£ä¿¡æ¯ | æä¾›å°ºå¯¸ã€DPIç­‰ä¿¡æ¯           |

  **ä¸è´Ÿè´£ï¼š**

  - âŒ åˆ›å»ºçª—å£
  - âŒ åˆ›å»ºæ¸²æŸ“å™¨
  - âŒ äº‹ä»¶æ•è·ï¼ˆåªå¤„ç†å·²è½¬æ¢çš„äº‹ä»¶ï¼‰

  ### 3.2 IGraphicsBackendæ¥å£

  **ä½ç½®**: `core/include/YuchenUI/rendering/IGraphicsBackend.h`

  å®šä¹‰æ¸²æŸ“å™¨çš„æŠ½è±¡æ¥å£ï¼ŒCoreå±‚å®šä¹‰ï¼ŒPlatformå±‚å®ç°ã€‚

  ```cpp
  class IGraphicsBackend {
  public:
      virtual ~IGraphicsBackend() = default;
      
      // å¸§ç®¡ç†
      virtual void beginFrame() = 0;
      virtual void endFrame() = 0;
      
      // æ¸²æŸ“
      virtual void executeRenderCommands(const RenderList& commands) = 0;
      
      // çº¹ç†ç®¡ç†ï¼ˆç»™TextRenderer/TextureCacheç”¨ï¼‰
      virtual void* createTexture2D(uint32_t width, uint32_t height, 
                                     TextureFormat format) = 0;
      virtual void updateTexture2D(void* texture, uint32_t x, uint32_t y,
                                   uint32_t width, uint32_t height,
                                   const void* data, size_t bytesPerRow) = 0;
      virtual void destroyTexture(void* texture) = 0;
      
      // è§†å£ä¿¡æ¯
      virtual Vec2 getRenderSize() const = 0;
  };
  ```

  ### 3.3 äº‹ä»¶å¤„ç†æœºåˆ¶

  **EventManageræ”¹ä¸ºçº¯è½¬æ¢å™¨ï¼š**

  ```cpp
  // ä¹‹å‰ï¼ˆæœ‰çŠ¶æ€ï¼‰
  class EventManager {
      EventQueue m_queue;
      EventCallback m_callback;
      void handleNativeEvent(void* event);  // æ”¾å…¥é˜Ÿåˆ—
      Event getNextEvent();
  };
  
  // ä¹‹åï¼ˆæ— çŠ¶æ€ï¼‰
  class EventManager {
      Event convertNativeEvent(void* event);  // çº¯è½¬æ¢
  };
  ```

  **äº‹ä»¶æµï¼š**

  ```
  NSEvent â†’ EventManager::convert() â†’ Eventå¯¹è±¡ â†’ UIContext::handleXxx()
  ```

  ### 3.4 ç»„ä»¶æ ‘ç®¡ç†

  **ç»„ä»¶æ‰€æœ‰æƒï¼š**

  ```
  IUIContent â†’ Widget â†’ å­Widget â†’ UIComponent
      â†‘          â†‘         â†‘           â†‘
     æ‹¥æœ‰       æ‹¥æœ‰      æ‹¥æœ‰        ä¸æ‹¥æœ‰ä»»ä½•ä¸œè¥¿
  ```

  **ä¸Šä¸‹æ–‡å¼•ç”¨ï¼š**

  ```
  UIContext â†â”€â”€â”€ IUIContent â†â”€â”€â”€ Widget â†â”€â”€â”€ UIComponent
      â†‘            æŒæœ‰å¼•ç”¨       æŒæœ‰å¼•ç”¨      æŒæœ‰å¼•ç”¨
     æ ¹å¯¹è±¡
  ```

  ### 3.5 DPIç¼©æ”¾ç®¡ç†

  **é›†ä¸­ç®¡ç†ï¼š**

  ```cpp
  UIContext::setDPIScale(2.0f);  // è®¾ç½®
  
  // å„ç»„ä»¶ä»ä¸Šä¸‹æ–‡è·å–
  float dpi = component->getOwnerContext()->getDPIScale();
  ```

  ### 3.6 èœå•å¼¹å‡ºæœºåˆ¶

  Menuåœ¨Coreå±‚ï¼Œä½†å¼¹å‡ºè¡Œä¸ºç”±Platformå±‚å®ç°ï¼š

  ```cpp
  // Coreå±‚
  class Menu {
      using PopupHandler = std::function<void(const Vec2& screenPos, Menu*)>;
      void setPopupHandler(PopupHandler handler);
      void popup(float x, float y);  // è§¦å‘handler
  };
  
  // Platformå±‚æ³¨å…¥
  menu->setPopupHandler([](const Vec2& pos, Menu* menu) {
      // macOSåŸç”Ÿèœå•å¼¹å‡º
  });
  ```

  ------

  ## 4. æ–‡ä»¶æ¸…å•ä¸æ”¹åŠ¨

  ### 4.1 Coreå±‚æ–‡ä»¶ï¼ˆ45ä¸ªï¼‰

  #### æ–°å¢æ–‡ä»¶ï¼ˆ3ä¸ªï¼‰

  | æ–‡ä»¶è·¯å¾„                             | ç±»å‹   | è¯´æ˜          |
  | ------------------------------------ | ------ | ------------- |
  | `core/include/YuchenUI/UIContext.h`  | å¤´æ–‡ä»¶ | æ ¸å¿ƒå…¥å£ç±»    |
  | `core/src/UIContext.cpp`             | å®ç°   | UIContextå®ç° |
  | `core/include/YuchenUI/IUIContent.h` | å¤´æ–‡ä»¶ | å†…å®¹æ¥å£      |

  #### é‡åº¦é‡æ„ï¼ˆ10ä¸ªï¼‰

  | æ–‡ä»¶è·¯å¾„                                            | æ”¹åŠ¨çº§åˆ« | å…³é”®æ”¹åŠ¨             |
  | --------------------------------------------------- | -------- | -------------------- |
  | `core/include/YuchenUI/widgets/UIComponent.h`       | ğŸ”´ é‡åº¦   | å»æ‰BaseWindowä¾èµ–   |
  | `core/src/widgets/UIComponent.cpp`                  | ğŸ”´ é‡åº¦   | é‡æ„captureMouseç­‰   |
  | `core/include/YuchenUI/widgets/Widget.h`            | ğŸ”´ é‡åº¦   | ä¿®æ”¹addChildé€»è¾‘     |
  | `core/src/widgets/Widget.cpp`                       | ğŸ”´ é‡åº¦   | å»æ‰çª—å£ç”Ÿå‘½å‘¨æœŸ     |
  | `core/include/YuchenUI/rendering/GraphicsContext.h` | ğŸ”´ é‡åº¦   | å˜æˆIGraphicsBackend |
  | `core/include/YuchenUI/widgets/TextInput.h`         | ğŸ”´ é‡åº¦   | IMEæ”¹ä¸ºä¸Šä¸‹æ–‡è·å–    |
  | `core/src/widgets/TextInput.cpp`                    | ğŸ”´ é‡åº¦   | ç„¦ç‚¹/IMEé€»è¾‘é‡æ„     |
  | `core/include/YuchenUI/focus/FocusManager.h`        | ğŸŸ¡ ä¸­åº¦   | æŒæœ‰UIContext*       |
  | `core/src/focus/FocusManager.cpp`                   | ğŸŸ¡ ä¸­åº¦   | ä¿®æ”¹æ‰€æœ‰è€…å¼•ç”¨       |
  | `core/include/YuchenUI/menu/Menu.h`                 | ğŸŸ¡ ä¸­åº¦   | æ·»åŠ PopupHandler     |

  #### ä¸­åº¦ä¿®æ”¹ï¼ˆ12ä¸ªWidgetï¼‰

  | æ–‡ä»¶              | æ”¹åŠ¨å†…å®¹                         |
  | ----------------- | -------------------------------- |
  | Button.h/cpp      | setOwnerWindow â†’ setOwnerContext |
  | TextLabel.h/cpp   | åŒä¸Š                             |
  | TextBlock.h/cpp   | åŒä¸Š                             |
  | Frame.h/cpp       | åŒä¸Š                             |
  | GroupBox.h/cpp    | åŒä¸Š                             |
  | Image.h/cpp       | åŒä¸Š                             |
  | CheckBox.h/cpp    | åŒä¸Š                             |
  | RadioButton.h/cpp | åŒä¸Š                             |
  | ComboBox.h/cpp    | åŒä¸Š + èœå•å¼¹å‡ºæ”¹ä¸ºå›è°ƒ          |
  | SpinBox.h/cpp     | åŒä¸Š                             |
  | ScrollArea.h/cpp  | åŒä¸Š                             |
  | IScrollable.h     | æ— æ”¹åŠ¨                           |

  #### è½»å¾®ä¿®æ”¹ï¼ˆ20ä¸ªï¼‰

  è¿™äº›æ–‡ä»¶åŸºæœ¬ä¿æŒä¸å˜ï¼Œåªéœ€ç§»åŠ¨åˆ°`core/`ç›®å½•ï¼š

  | ç›®å½•       | æ–‡ä»¶æ•° | è¯´æ˜                                                         |
  | ---------- | ------ | ------------------------------------------------------------ |
  | core/      | 5      | Assert.h, Colors.h, Config.h, Types.h, Validation.h          |
  | text/      | 6      | Font.h/cpp, FontManager.h/cpp, TextRenderer.h/cpp, GlyphCache.h/cpp, TextUtils.h/cpp |
  | theme/     | 4      | Theme.h/cpp, ThemeManager.h/cpp                              |
  | rendering/ | 2      | RenderList.h/cpp                                             |
  | image/     | 2      | ImageDecoder.h/cpp, TextureCache.h/cppï¼ˆè½»å¾®ä¿®æ”¹ï¼‰           |
  | debugging/ | 1      | debug.h                                                      |

  ------

  ### 4.2 Platformå±‚æ–‡ä»¶ï¼ˆ15ä¸ªï¼‰

  #### ç§»åŠ¨+é‡æ„ï¼ˆ8ä¸ªï¼‰

  | åŸè·¯å¾„                                     | æ–°è·¯å¾„                                              | æ”¹åŠ¨  |
  | ------------------------------------------ | --------------------------------------------------- | ----- |
  | `include/YuchenUI/windows/Window.h`        | `platform/include/YuchenUI/windows/Window.h`        | æ—     |
  | `include/YuchenUI/windows/BaseWindow.h`    | `platform/include/YuchenUI/windows/BaseWindow.h`    | ğŸ”´é‡åº¦ |
  | `src/windows/BaseWindow.cpp`               | `platform/src/windows/BaseWindow.cpp`               | ğŸ”´é‡åº¦ |
  | `include/YuchenUI/windows/WindowManager.h` | `platform/include/YuchenUI/windows/WindowManager.h` | ğŸŸ¡ä¸­åº¦ |
  | `src/windows/WindowManager.cpp`            | `platform/src/windows/WindowManager.cpp`            | ğŸŸ¡ä¸­åº¦ |
  | `include/YuchenUI/platform/WindowImpl.h`   | `platform/include/YuchenUI/platform/WindowImpl.h`   | è½»å¾®  |
  | `src/platform/macos/MacOSWindowImpl.mm`    | `platform/src/macos/MacOSWindowImpl.mm`             | ğŸŸ¡ä¸­åº¦ |
  | `src/platform/macos/MacEventManager.mm`    | `platform/src/macos/MacEventManager.mm`             | ğŸŸ¡ä¸­åº¦ |

  #### é‡åº¦é‡æ„ï¼ˆ3ä¸ªï¼‰

  | æ–‡ä»¶                                                   | æ”¹åŠ¨è¯´æ˜                          |
  | ------------------------------------------------------ | --------------------------------- |
  | `platform/src/macos/MetalRenderer.mm`                  | å®ç°IGraphicsBackendæ¥å£          |
  | `platform/src/macos/MacMenuImpl.mm`                    | é€‚é…æ–°çš„Menuå›è°ƒæœºåˆ¶              |
  | `platform/include/YuchenUI/platform/PlatformBackend.h` | å·¥å‚æ–¹æ³•æ”¹ä¸ºè¿”å›IGraphicsBackend* |

  #### ç§»åŠ¨ä¸æ”¹åŠ¨ï¼ˆ4ä¸ªï¼‰

  | æ–‡ä»¶                                              | è¯´æ˜     |
  | ------------------------------------------------- | -------- |
  | `platform/include/YuchenUI/events/EventManager.h` | ç§»åŠ¨ä½ç½® |
  | `platform/include/YuchenUI/platform/MenuImpl.h`   | ç§»åŠ¨ä½ç½® |
  | `platform/include/YuchenUI/utils/Clipboard.h`     | ç§»åŠ¨ä½ç½® |
  | `platform/src/utils/Clipboard.cpp`                | ç§»åŠ¨ä½ç½® |

  #### åˆ é™¤æ–‡ä»¶ï¼ˆ2ä¸ªï¼‰

  | æ–‡ä»¶                                        | åŸå›              |
  | ------------------------------------------- | ---------------- |
  | `include/YuchenUI/windows/IWindowContent.h` | è¢«IUIContentæ›¿ä»£ |
  | `src/windows/IWindowContent.cpp`            | è¢«IUIContentæ›¿ä»£ |

  ------

  ## 5. è¯¦ç»†é‡æ„æŒ‡å—

  ### 5.1 Phase 1: Coreå±‚åŸºç¡€æ„å»º

  #### 5.1.1 åˆ›å»ºUIContext.h

  **æ–‡ä»¶**: `core/include/YuchenUI/UIContext.h`

  ```cpp
  #pragma once
  
  #include "YuchenUI/core/Types.h"
  #include "YuchenUI/events/Event.h"
  #include <memory>
  
  namespace YuchenUI {
  
  class IUIContent;
  class IGraphicsBackend;
  class FocusManager;
  class UIComponent;
  
  class UIContext {
  public:
      UIContext();
      ~UIContext();
      
      // === å†…å®¹ç®¡ç† ===
      void setContent(std::unique_ptr<IUIContent> content);
      IUIContent* getContent() const;
      
      // === æ¸²æŸ“å¾ªç¯ ===
      void beginFrame();
      void render(RenderList& outCommandList);
      void endFrame();
      
      // === è¾“å…¥å¤„ç† ===
      bool handleMouseMove(const Vec2& position);
      bool handleMouseClick(const Vec2& position, bool pressed);
      bool handleMouseWheel(const Vec2& delta, const Vec2& position);
      bool handleKeyEvent(KeyCode key, bool pressed, const KeyModifiers& mods, bool isRepeat);
      bool handleTextInput(uint32_t codepoint);
      bool handleTextComposition(const char* text, int cursorPos, int selectionLength);
      
      // === è§†å£ä¿¡æ¯ ===
      void setViewportSize(const Vec2& size);
      Vec2 getViewportSize() const;
      void setDPIScale(float scale);
      float getDPIScale() const;
      
      // === ç„¦ç‚¹ç®¡ç† ===
      FocusManager& getFocusManager();
      const FocusManager& getFocusManager() const;
      
      // === é¼ æ ‡æ•è· ===
      void captureMouse(UIComponent* component);
      void releaseMouse();
      UIComponent* getCapturedComponent() const;
      
      // === IMEæ”¯æŒ ===
      Rect getInputMethodCursorRect() const;
      
      // === å†…éƒ¨ä½¿ç”¨ ===
      void addComponent(UIComponent* component);
      void removeComponent(UIComponent* component);
  
  private:
      struct Impl;
      std::unique_ptr<Impl> m_impl;
      
      UIContext(const UIContext&) = delete;
      UIContext& operator=(const UIContext&) = delete;
  };
  
  } // namespace YuchenUI
  ```

  #### 5.1.2 åˆ›å»ºUIContext.cpp

  **æ–‡ä»¶**: `core/src/UIContext.cpp`

  ```cpp
  #include "YuchenUI/UIContext.h"
  #include "YuchenUI/IUIContent.h"
  #include "YuchenUI/focus/FocusManager.h"
  #include "YuchenUI/widgets/UIComponent.h"
  #include "YuchenUI/rendering/RenderList.h"
  #include <vector>
  #include <algorithm>
  #include <chrono>
  
  namespace YuchenUI {
  
  struct UIContext::Impl {
      std::unique_ptr<IUIContent> content;
      std::unique_ptr<FocusManager> focusManager;
      std::vector<UIComponent*> components;
      
      Vec2 viewportSize;
      float dpiScale;
      
      UIComponent* capturedComponent;
      
      // æ—¶é—´ç®¡ç†
      std::chrono::time_point<std::chrono::high_resolution_clock> lastFrameTime;
      
      Impl()
          : content(nullptr)
          , focusManager(nullptr)
          , viewportSize(800, 600)
          , dpiScale(1.0f)
          , capturedComponent(nullptr)
          , lastFrameTime(std::chrono::high_resolution_clock::now())
      {}
  };
  
  UIContext::UIContext()
      : m_impl(std::make_unique<Impl>())
  {
      m_impl->focusManager = std::make_unique<FocusManager>(nullptr);
  }
  
  UIContext::~UIContext() = default;
  
  // === å†…å®¹ç®¡ç† ===
  
  void UIContext::setContent(std::unique_ptr<IUIContent> content) {
      if (m_impl->content) {
          m_impl->content->onDestroy();
      }
      
      m_impl->content = std::move(content);
      
      if (m_impl->content) {
          Rect contentArea(0, 0, m_impl->viewportSize.x, m_impl->viewportSize.y);
          m_impl->content->onCreate(this, contentArea);
      }
  }
  
  IUIContent* UIContext::getContent() const {
      return m_impl->content.get();
  }
  
  // === æ¸²æŸ“å¾ªç¯ ===
  
  void UIContext::beginFrame() {
      // è®¡ç®—deltaTime
      auto now = std::chrono::high_resolution_clock::now();
      float deltaTime = std::chrono::duration<float>(now - m_impl->lastFrameTime).count();
      m_impl->lastFrameTime = now;
      
      // æ›´æ–°æ‰€æœ‰ç»„ä»¶
      if (m_impl->content) {
          m_impl->content->onUpdate(deltaTime);
      }
  }
  
  void UIContext::render(RenderList& outCommandList) {
      if (m_impl->content) {
          m_impl->content->render(outCommandList);
      }
  }
  
  void UIContext::endFrame() {
      // é¢„ç•™ç»™æœªæ¥çš„æ¸…ç†å·¥ä½œ
  }
  
  // === è¾“å…¥å¤„ç† ===
  
  bool UIContext::handleMouseMove(const Vec2& position) {
      // ä¼˜å…ˆå‘é€åˆ°æ•è·çš„ç»„ä»¶
      if (m_impl->capturedComponent) {
          return m_impl->capturedComponent->handleMouseMove(position);
      }
      
      // å¦åˆ™å‘é€åˆ°å†…å®¹
      if (m_impl->content) {
          return m_impl->content->handleMouseMove(position);
      }
      
      return false;
  }
  
  bool UIContext::handleMouseClick(const Vec2& position, bool pressed) {
      // ä¼˜å…ˆå‘é€åˆ°æ•è·çš„ç»„ä»¶
      if (m_impl->capturedComponent) {
          return m_impl->capturedComponent->handleMouseClick(position, pressed);
      }
      
      // å¦åˆ™å‘é€åˆ°å†…å®¹
      if (m_impl->content) {
          return m_impl->content->handleMouseClick(position, pressed);
      }
      
      return false;
  }
  
  bool UIContext::handleMouseWheel(const Vec2& delta, const Vec2& position) {
      if (m_impl->content) {
          return m_impl->content->handleMouseWheel(delta, position);
      }
      return false;
  }
  
  bool UIContext::handleKeyEvent(KeyCode key, bool pressed, const KeyModifiers& mods, bool isRepeat) {
      if (m_impl->content) {
          Event event;
          event.type = pressed ? EventType::KeyPressed : EventType::KeyReleased;
          event.key.key = key;
          event.key.modifiers = mods;
          event.key.isRepeat = isRepeat;
          
          return m_impl->content->handleKeyEvent(event);
      }
      return false;
  }
  
  bool UIContext::handleTextInput(uint32_t codepoint) {
      if (m_impl->content) {
          Event event;
          event.type = EventType::TextInput;
          event.textInput.codepoint = codepoint;
          
          return m_impl->content->handleTextInput(event);
      }
      return false;
  }
  
  bool UIContext::handleTextComposition(const char* text, int cursorPos, int selectionLength) {
      if (m_impl->content) {
          Event event;
          event.type = EventType::TextComposition;
          strncpy(event.textComposition.text, text, 255);
          event.textComposition.text[255] = '\0';
          event.textComposition.cursorPosition = cursorPos;
          event.textComposition.selectionLength = selectionLength;
          
          return m_impl->content->handleTextInput(event);
      }
      return false;
  }
  
  // === è§†å£ä¿¡æ¯ ===
  
  void UIContext::setViewportSize(const Vec2& size) {
      m_impl->viewportSize = size;
      
      if (m_impl->content) {
          Rect newArea(0, 0, size.x, size.y);
          m_impl->content->onResize(newArea);
      }
  }
  
  Vec2 UIContext::getViewportSize() const {
      return m_impl->viewportSize;
  }
  
  void UIContext::setDPIScale(float scale) {
      m_impl->dpiScale = scale;
  }
  
  float UIContext::getDPIScale() const {
      return m_impl->dpiScale;
  }
  
  // === ç„¦ç‚¹ç®¡ç† ===
  
  FocusManager& UIContext::getFocusManager() {
      return *m_impl->focusManager;
  }
  
  const FocusManager& UIContext::getFocusManager() const {
      return *m_impl->focusManager;
  }
  
  // === é¼ æ ‡æ•è· ===
  
  void UIContext::captureMouse(UIComponent* component) {
      m_impl->capturedComponent = component;
  }
  
  void UIContext::releaseMouse() {
      m_impl->capturedComponent = nullptr;
  }
  
  UIComponent* UIContext::getCapturedComponent() const {
      return m_impl->capturedComponent;
  }
  
  // === IMEæ”¯æŒ ===
  
  Rect UIContext::getInputMethodCursorRect() const {
      if (m_impl->content) {
          return m_impl->content->getInputMethodCursorRect();
      }
      return Rect();
  }
  
  // === å†…éƒ¨ä½¿ç”¨ ===
  
  void UIContext::addComponent(UIComponent* component) {
      auto it = std::find(m_impl->components.begin(), m_impl->components.end(), component);
      if (it == m_impl->components.end()) {
          m_impl->components.push_back(component);
      }
  }
  
  void UIContext::removeComponent(UIComponent* component) {
      auto it = std::find(m_impl->components.begin(), m_impl->components.end(), component);
      if (it != m_impl->components.end()) {
          m_impl->components.erase(it);
      }
  }
  
  } // namespace YuchenUI
  ```

  #### 5.1.3 åˆ›å»ºIUIContent.h

  **æ–‡ä»¶**: `core/include/YuchenUI/IUIContent.h`

  ```cpp
  #pragma once
  
  #include "YuchenUI/core/Types.h"
  #include "YuchenUI/events/Event.h"
  #include <vector>
  #include <memory>
  
  namespace YuchenUI {
  
  class UIContext;
  class RenderList;
  class UIComponent;
  class FocusManager;
  
  class IUIContent {
  public:
      IUIContent();
      virtual ~IUIContent();
      
      // === ç”Ÿå‘½å‘¨æœŸï¼ˆæ— Windowå‚æ•°ï¼‰ ===
      virtual void onCreate(UIContext* context, const Rect& contentArea) = 0;
      virtual void onDestroy() {}
      virtual void onResize(const Rect& newArea) {}
      virtual void onUpdate(float deltaTime) {}
      virtual void render(RenderList& commandList) = 0;
      
      // === äº‹ä»¶å¤„ç† ===
      virtual bool handleMouseMove(const Vec2& position);
      virtual bool handleMouseClick(const Vec2& position, bool pressed);
      virtual bool handleMouseWheel(const Vec2& delta, const Vec2& position);
      virtual bool handleKeyEvent(const Event& event);
      virtual bool handleTextInput(const Event& event);
      
      // === IMEæ”¯æŒ ===
      virtual Rect getInputMethodCursorRect() const;
      
      // === ç»„ä»¶ç®¡ç†ï¼ˆå­ç±»ä½¿ç”¨ï¼‰ ===
      void addComponent(UIComponent* component);
      void removeComponent(UIComponent* component);
      void clearComponents();
      
      // === ç„¦ç‚¹ç®¡ç† ===
      UIComponent* getFocusedComponent() const;
      void registerFocusableComponent(UIComponent* component);
      void unregisterFocusableComponent(UIComponent* component);
  
  protected:
      UIContext* m_context;
      Rect m_contentArea;
      std::vector<UIComponent*> m_components;
      
  private:
      bool handleMouseEvent(const Vec2& position, bool pressed, bool isMoveEvent);
  };
  
  } // namespace YuchenUI
  ```

  **æ–‡ä»¶**: `core/src/IUIContent.cpp`

  ```cpp
  #include "YuchenUI/IUIContent.h"
  #include "YuchenUI/UIContext.h"
  #include "YuchenUI/widgets/UIComponent.h"
  #include "YuchenUI/focus/FocusManager.h"
  #include "YuchenUI/rendering/RenderList.h"
  #include <algorithm>
  
  namespace YuchenUI {
  
  IUIContent::IUIContent()
      : m_context(nullptr)
      , m_contentArea()
      , m_components()
  {}
  
  IUIContent::~IUIContent() {
      clearComponents();
  }
  
  // === äº‹ä»¶å¤„ç† ===
  
  bool IUIContent::handleMouseEvent(const Vec2& position, bool pressed, bool isMoveEvent) {
      // ä»åå¾€å‰æµ‹è¯•ï¼ˆæœ€ä¸Šå±‚å…ˆå“åº”ï¼‰
      for (auto it = m_components.rbegin(); it != m_components.rend(); ++it) {
          UIComponent* component = *it;
          if (component && component->isVisible() && component->isEnabled()) {
              bool handled = isMoveEvent 
                  ? component->handleMouseMove(position)
                  : component->handleMouseClick(position, pressed);
              
              if (handled) {
                  if (!isMoveEvent && pressed) {
                      // ç‚¹å‡»æ—¶å°è¯•è·å¾—ç„¦ç‚¹
                      if (component->canAcceptFocus()) {
                          component->setFocus(FocusReason::MouseFocusReason);
                      }
                  }
                  return true;
              }
          }
      }
      
      // æ²¡æœ‰ç»„ä»¶å¤„ç†ï¼Œç‚¹å‡»ç©ºç™½å¤„æ¸…é™¤ç„¦ç‚¹
      if (!isMoveEvent && !pressed && m_context) {
          m_context->getFocusManager().clearFocus();
      }
      
      return false;
  }
  
  bool IUIContent::handleMouseMove(const Vec2& position) {
      return handleMouseEvent(position, false, true);
  }
  
  bool IUIContent::handleMouseClick(const Vec2& position, bool pressed) {
      return handleMouseEvent(position, pressed, false);
  }
  
  bool IUIContent::handleMouseWheel(const Vec2& delta, const Vec2& position) {
      for (auto it = m_components.rbegin(); it != m_components.rend(); ++it) {
          UIComponent* component = *it;
          if (component && component->isVisible() && component->isEnabled()) {
              if (component->handleMouseWheel(delta, position)) {
                  return true;
              }
          }
      }
      return false;
  }
  
  bool IUIContent::handleKeyEvent(const Event& event) {
      if (!m_context) return false;
      
      auto* focused = m_context->getFocusManager().getFocusedComponent();
      if (focused && focused->isVisible() && focused->isEnabled()) {
          return focused->handleKeyPress(event);
      }
      
      return false;
  }
  
  bool IUIContent::handleTextInput(const Event& event) {
      if (!m_context) return false;
      
      auto* focused = m_context->getFocusManager().getFocusedComponent();
      if (!focused || !focused->isVisible() || !focused->isEnabled()) {
          return false;
      }
      
      if (event.type == EventType::TextComposition) {
          return focused->handleComposition(
              event.textComposition.text,
              event.textComposition.cursorPosition,
              event.textComposition.selectionLength
          );
      }
      
      return focused->handleTextInput(event.textInput.codepoint);
  }
  
  Rect IUIContent::getInputMethodCursorRect() const {
      if (!m_context) return Rect();
      
      auto* focused = m_context->getFocusManager().getFocusedComponent();
      if (!focused) return Rect();
      
      // æŸ¥è¯¢æ”¯æŒIMEçš„ç»„ä»¶
      IInputMethodSupport* inputSupport = dynamic_cast<IInputMethodSupport*>(focused);
      if (!inputSupport) return Rect();
      
      Rect localRect = inputSupport->getInputMethodCursorRect();
      return focused->mapToWindow(localRect);
  }
  
  // === ç»„ä»¶ç®¡ç† ===
  
  void IUIContent::addComponent(UIComponent* component) {
      if (!component) return;
      
      if (m_context) {
          component->setOwnerContext(m_context);
          m_context->addComponent(component);
      }
      
      auto it = std::find(m_components.begin(), m_components.end(), component);
      if (it == m_components.end()) {
          m_components.push_back(component);
      }
  }
  
  void IUIContent::removeComponent(UIComponent* component) {
      if (!component) return;
      
      if (m_context) {
          unregisterFocusableComponent(component);
          m_context->removeComponent(component);
      }
      
      auto it = std::find(m_components.begin(), m_components.end(), component);
      if (it != m_components.end()) {
          m_components.erase(it);
      }
  }
  
  void IUIContent::clearComponents() {
      if (m_context) {
          m_context->getFocusManager().clearFocus();
      }
      m_components.clear();
  }
  
  UIComponent* IUIContent::getFocusedComponent() const {
      if (!m_context) return nullptr;
      return m_context->getFocusManager().getFocusedComponent();
  }
  
  void IUIContent::registerFocusableComponent(UIComponent* component) {
      if (m_context && component->getFocusPolicy() != FocusPolicy::NoFocus) {
          m_context->getFocusManager().registerComponent(component);
      }
  }
  
  void IUIContent::unregisterFocusableComponent(UIComponent* component) {
      if (m_context) {
          m_context->getFocusManager().unregisterComponent(component);
      }
  }
  
  } // namespace YuchenUI
  ```

  #### 5.1.4 åˆ›å»ºIGraphicsBackend.h

  **æ–‡ä»¶**: `core/include/YuchenUI/rendering/IGraphicsBackend.h`

  ```cpp
  #pragma once
  
  #include "YuchenUI/core/Types.h"
  
  namespace YuchenUI {
  
  class RenderList;
  
  // æ¸²æŸ“å™¨æŠ½è±¡æ¥å£ï¼ˆCoreå±‚å®šä¹‰ï¼ŒPlatformå±‚å®ç°ï¼‰
  class IGraphicsBackend {
  public:
      virtual ~IGraphicsBackend() = default;
      
      // === å¸§ç®¡ç† ===
      virtual void beginFrame() = 0;
      virtual void endFrame() = 0;
      
      // === æ¸²æŸ“ ===
      virtual void executeRenderCommands(const RenderList& commands) = 0;
      
      // === çº¹ç†ç®¡ç†ï¼ˆç»™TextRenderer/TextureCacheç”¨ï¼‰ ===
      virtual void* createTexture2D(uint32_t width, uint32_t height, 
                                     TextureFormat format) = 0;
      virtual void updateTexture2D(void* texture, uint32_t x, uint32_t y,
                                   uint32_t width, uint32_t height,
                                   const void* data, size_t bytesPerRow) = 0;
      virtual void destroyTexture(void* texture) = 0;
      
      // === è§†å£ä¿¡æ¯ ===
      virtual Vec2 getRenderSize() const = 0;
      virtual float getDPIScale() const = 0;
  };
  
  } // namespace YuchenUI
  ```

  ------

  ### 5.2 Phase 2: Widgetå±‚é‡æ„

  #### 5.2.1 é‡æ„UIComponent

  **æ–‡ä»¶**: `core/include/YuchenUI/widgets/UIComponent.h`

  **æ”¹åŠ¨æ¸…å•ï¼š**

  ```cpp
  // ã€åˆ é™¤ã€‘
  class BaseWindow;
  void setOwnerWindow(BaseWindow* window);
  BaseWindow* getOwnerWindow() const;
  BaseWindow* m_ownerWindow;
  
  // ã€æ–°å¢ã€‘
  class UIContext;
  void setOwnerContext(UIContext* context);
  UIContext* getOwnerContext() const;
  UIContext* m_ownerContext;
  
  // ã€ä¿®æ”¹ã€‘captureMouseå®ç°
  void captureMouse() {
      // ä¹‹å‰ï¼šm_ownerWindow->captureMouse(this);
      // ä¹‹åï¼šm_ownerContext->captureMouse(this);
  }
  ```

  **å®Œæ•´ä»£ç ï¼š**

  ```cpp
  // core/include/YuchenUI/widgets/UIComponent.h
  #pragma once
  
  #include "YuchenUI/core/Types.h"
  #include "YuchenUI/events/Event.h"
  #include "YuchenUI/focus/FocusPolicy.h"
  
  namespace YuchenUI {
  
  class RenderList;
  class UIContext;  // æ”¹ï¼šä¸å†æ˜¯BaseWindow
  class IUIContent;
  class Menu;
  
  class UIComponent {
  public:
      UIComponent();
      virtual ~UIComponent() = default;
      
      // === æ¸²æŸ“å’Œäº‹ä»¶ ===
      virtual void addDrawCommands(RenderList& commandList, const Vec2& offset = Vec2()) const = 0;
      virtual bool handleMouseMove(const Vec2& position, const Vec2& offset = Vec2()) = 0;
      virtual bool handleMouseClick(const Vec2& position, bool pressed, const Vec2& offset = Vec2()) = 0;
      virtual bool handleMouseWheel(const Vec2& delta, const Vec2& position, const Vec2& offset = Vec2()) { return false; }
      virtual bool handleKeyPress(const Event& event) { return false; }
      virtual bool handleTextInput(uint32_t codepoint) { return false; }
      virtual bool handleComposition(const char* text, int cursorPos, int selectionLength) { return false; }
      virtual void update(float deltaTime) {}
      
      virtual const Rect& getBounds() const = 0;
      Rect mapToWindow(const Rect& localRect) const;
      
      // === å¯è§æ€§å’Œå¯ç”¨ ===
      virtual bool isVisible() const { return m_isVisible; }
      virtual void setVisible(bool visible);
      virtual bool isEnabled() const { return m_isEnabled; }
      virtual void setEnabled(bool enabled);
      
      // === æ‰€æœ‰è€…ï¼ˆæ”¹ï¼šUIContextæ›¿ä»£BaseWindowï¼‰ ===
      virtual void setOwnerContext(UIContext* context) { m_ownerContext = context; }
      UIContext* getOwnerContext() const { return m_ownerContext; }
      
      virtual void setOwnerContent(IUIContent* content) { m_ownerContent = content; }
      IUIContent* getOwnerContent() const { return m_ownerContent; }
      
      void setParent(UIComponent* parent) { m_parent = parent; }
      UIComponent* getParent() const { return m_parent; }
      
      // === å³é”®èœå• ===
      void setContextMenu(Menu* menu) { m_contextMenu = menu; }
      Menu* getContextMenu() const { return m_contextMenu; }
      bool hasContextMenu() const { return m_contextMenu != nullptr; }
      
      // === ç„¦ç‚¹ç®¡ç† ===
      void setFocusPolicy(FocusPolicy policy);
      FocusPolicy getFocusPolicy() const { return m_focusPolicy; }
      bool canAcceptFocus() const;
      bool hasFocus() const { return m_hasFocus; }
      void setFocus(FocusReason reason = FocusReason::OtherFocusReason);
      void clearFocus();
      
  protected:
      // æ”¹ï¼šé€šè¿‡UIContextæ•è·
      void captureMouse();
      void releaseMouse();
      
      virtual void drawFocusIndicator(RenderList& commandList, const Vec2& offset) const;
      virtual CornerRadius getFocusIndicatorCornerRadius() const { return CornerRadius(); }
      
      virtual void focusInEvent(FocusReason reason) {}
      virtual void focusOutEvent(FocusReason reason) {}
      
      bool m_isVisible;
      bool m_isEnabled;
      UIContext* m_ownerContext;      // æ”¹ï¼šæ›¿ä»£m_ownerWindow
      IUIContent* m_ownerContent;
      UIComponent* m_parent;
      Menu* m_contextMenu;
  
  private:
      FocusPolicy m_focusPolicy;
      bool m_hasFocus;
      // ... å…¶ä»–æˆå‘˜
      
      friend class FocusManager;
      friend class IUIContent;
  };
  
  } // namespace YuchenUI
  ```

  **æ–‡ä»¶**: `core/src/widgets/UIComponent.cpp`

  **æ”¹åŠ¨è¦ç‚¹ï¼š**

  ```cpp
  // 1. åŒ…å«å¤´æ–‡ä»¶æ”¹åŠ¨
  #include "YuchenUI/UIContext.h"  // æ”¹ï¼šä¸å†åŒ…å«BaseWindow.h
  
  // 2. captureMouseå®ç°
  void UIComponent::captureMouse() {
      if (m_ownerContext) {  // æ”¹ï¼šä¸å†æ˜¯m_ownerWindow
          m_ownerContext->captureMouse(this);
      }
  }
  
  void UIComponent::releaseMouse() {
      if (m_ownerContext) {  // æ”¹ï¼šä¸å†æ˜¯m_ownerWindow
          m_ownerContext->releaseMouse();
      }
  }
  
  // 3. setFocuså®ç°
  void UIComponent::setFocus(FocusReason reason) {
      if (!m_ownerContext) return;
      m_ownerContext->getFocusManager().setFocus(this, reason);
  }
  
  // 4. mapToWindowä¿æŒä¸å˜ï¼ˆé€»è¾‘ç›¸åŒï¼‰
  Rect UIComponent::mapToWindow(const Rect& localRect) const {
      // å®ç°ä¿æŒä¸å˜
  }
  ```

  #### 5.2.2 é‡æ„Widget

  **æ–‡ä»¶**: `core/include/YuchenUI/widgets/Widget.h`

  **æ”¹åŠ¨æ¸…å•ï¼š**

  ```cpp
  // ã€ä¿®æ”¹ã€‘addChildæ–¹æ³•ä¸­çš„è®¾ç½®é¡ºåº
  template<typename T, typename... Args>
  T* addChild(Args&&... args) {
      auto child = std::make_unique<T>(std::forward<Args>(args)...);
      T* ptr = child.get();
      
      // è®¾ç½®å…³ç³»
      ptr->setOwnerContext(m_ownerContext);  // æ”¹ï¼šä¸å†æ˜¯m_ownerWindow
      ptr->setParent(this);
      
      m_children.push_back(std::move(child));
      
      // è®¾ç½®å†…å®¹å’Œæ³¨å†Œç„¦ç‚¹
      ptr->setOwnerContent(m_ownerContent);
      if (m_ownerContent) {
          if (ptr->getFocusPolicy() != FocusPolicy::NoFocus) {
              m_ownerContent->registerFocusableComponent(ptr);
          }
      }
      
      return ptr;
  }
  
  // ã€ä¿®æ”¹ã€‘setOwnerContextä¼ é€’ç»™å­ç»„ä»¶
  void setOwnerContext(UIContext* context) override {
      m_ownerContext = context;
      for (auto& child : m_children) {
          if (child) child->setOwnerContext(context);
      }
  }
  ```

  **å®Œæ•´ä»£ç è§æ–‡ä»¶**ï¼š`core/src/widgets/Widget.cpp`

  æ”¹åŠ¨è¾ƒå°‘ï¼Œä¸»è¦æ˜¯å°†`BaseWindow`æ›¿æ¢ä¸º`UIContext`ã€‚

  #### 5.2.3 æ‰¹é‡ä¿®æ”¹å…¶ä»–Widget

  **éœ€è¦ä¿®æ”¹çš„Widgetåˆ—è¡¨ï¼š**

  - Button.h/cpp
  - TextLabel.h/cpp
  - TextBlock.h/cpp
  - Frame.h/cpp
  - GroupBox.h/cpp
  - Image.h/cpp
  - CheckBox.h/cpp
  - RadioButton.h/cpp
  - ComboBox.h/cpp
  - SpinBox.h/cpp
  - ScrollArea.h/cpp

  **ç»Ÿä¸€æ”¹åŠ¨æ¨¡å¼ï¼š**

  1. åŒ…å«å¤´æ–‡ä»¶ï¼š

  ```cpp
  // åˆ é™¤
  #include "YuchenUI/windows/BaseWindow.h"
  
  // æ”¹ä¸ºï¼ˆå¦‚æœéœ€è¦ï¼‰
  #include "YuchenUI/UIContext.h"
  ```

  1. æ„é€ å‡½æ•°æ— æ”¹åŠ¨
  2. æˆå‘˜å‡½æ•°ä¸­è®¿é—®çª—å£çš„åœ°æ–¹ï¼š

  ```cpp
  // ä¹‹å‰
  if (m_ownerWindow) {
      m_ownerWindow->enableTextInput();
  }
  
  // ä¹‹å
  // TextInputéœ€è¦IMEï¼Œä½†UIContextä¸æä¾›enableTextInput
  // æ”¹ä¸ºï¼šä¸åœ¨Widgetä¸­ç›´æ¥è°ƒç”¨ï¼Œç”±focusInEventè§¦å‘
  ```

  **ç‰¹æ®Šå¤„ç†ï¼šTextInput**

  TextInputéœ€è¦IMEæ”¯æŒï¼Œæ”¹ä¸ºï¼š

  ```cpp
  // TextInput.cpp
  void TextInput::focusInEvent(FocusReason reason) {
      // é€šè¿‡å†…å®¹å±‚è¯·æ±‚æ–‡æœ¬è¾“å…¥
      if (m_ownerContent) {
          m_ownerContent->requestTextInput(true);
      }
  }
  
  void TextInput::focusOutEvent(FocusReason reason) {
      if (m_ownerContent) {
          m_ownerContent->requestTextInput(false);
      }
  }
  ```

  ç„¶ååœ¨IUIContentä¸­ï¼š

  ```cpp
  // IUIContent.h
  virtual void requestTextInput(bool enable) {}  // å­ç±»å¯é€‰å®ç°
  ```

  Platformå±‚çš„å®ç°ä¼šé€šè¿‡BaseWindowè½¬å‘åˆ°å¹³å°çª—å£ã€‚

  #### 5.2.4 é‡æ„ComboBoxèœå•

  **æ–‡ä»¶**: `core/include/YuchenUI/widgets/ComboBox.h`

  **æ”¹åŠ¨ï¼š**

  ```cpp
  // ã€æ–°å¢ã€‘èœå•å¼¹å‡ºå¤„ç†å™¨
  using MenuPopupHandler = std::function<void(const Vec2& screenPos, Menu* menu)>;
  
  void setMenuPopupHandler(MenuPopupHandler handler) {
      m_menuPopupHandler = handler;
  }
  
  private:
  MenuPopupHandler m_menuPopupHandler;
  ```

  **æ–‡ä»¶**: `core/src/widgets/ComboBox.cpp`

  ```cpp
  void ComboBox::openMenu() {
      buildMenu();
      
      // è®¡ç®—å±å¹•åæ ‡
      Rect bounds = getBounds();
      Vec2 screenPos = mapToWindow(Rect(bounds.x, bounds.y + bounds.height, 0, 0)).position;
      
      // é€šè¿‡handlerå¼¹å‡ºï¼ˆå¦‚æœè®¾ç½®ï¼‰
      if (m_menuPopupHandler && m_menu) {
          m_menuPopupHandler(screenPos, m_menu.get());
      } else {
          // å¦åˆ™ä½¿ç”¨Menuè‡ªå·±çš„popup
          if (m_menu) {
              m_menu->popup(screenPos.x, screenPos.y);
          }
      }
  }
  ```

  ------

  ### 5.3 Phase 3: Platformå±‚æ”¹é€ 

  #### 5.3.1 é‡æ„BaseWindow

  **æ–‡ä»¶**: `platform/include/YuchenUI/windows/BaseWindow.h`

  **æ”¹åŠ¨æ¸…å•ï¼š**

  ```cpp
  // ã€æ–°å¢ã€‘
  #include "YuchenUI/UIContext.h"
  #include "YuchenUI/rendering/IGraphicsBackend.h"
  
  // ã€åˆ é™¤ã€‘
  #include "YuchenUI/rendering/GraphicsContext.h"
  #include "YuchenUI/windows/IWindowContent.h"
  
  // ã€æ”¹ã€‘æˆå‘˜å˜é‡
  UIContext m_uiContext;                          // æ–°å¢ï¼šUIä¸Šä¸‹æ–‡
  std::unique_ptr<IGraphicsBackend> m_backend;    // æ”¹ï¼šæŠ½è±¡æ¥å£
  
  // ã€åˆ ã€‘
  GraphicsContext* m_renderer;
  std::unique_ptr<IWindowContent> m_content;
  
  // ã€æ”¹ã€‘setContentæ–¹æ³•
  template<typename ContentType, typename... Args>
  void setContent(Args&&... args) {
      auto content = std::make_unique<ContentType>(std::forward<Args>(args)...);
      m_uiContext.setContent(std::move(content));
  }
  ```

  **å®Œæ•´ä»£ç ï¼š**

  ```cpp
  // platform/include/YuchenUI/windows/BaseWindow.h
  #pragma once
  
  #include "YuchenUI/windows/Window.h"
  #include "YuchenUI/core/Types.h"
  #include "YuchenUI/UIContext.h"                    // æ–°å¢
  #include "YuchenUI/rendering/IGraphicsBackend.h"   // æ–°å¢
  #include <memory>
  #include <functional>
  
  namespace YuchenUI {
  
  class EventManager;
  class WindowImpl;
  class IUIContent;
  
  using DialogResultCallback = std::function<void(WindowContentResult result, void* userData)>;
  
  enum class WindowState {
      Uninitialized,
      Created,
      RendererReady,
      Shown
  };
  
  class BaseWindow : public Window {
  public:
      explicit BaseWindow(WindowType type = WindowType::Main);
      virtual ~BaseWindow();
      
      // === çª—å£åˆ›å»º ===
      bool create(int width, int height, const char* title, Window* parent = nullptr) override;
      void destroy() override;
      
      // === å†…å®¹è®¾ç½® ===
      template<typename ContentType, typename... Args>
      void setContent(Args&&... args) {
          auto content = std::make_unique<ContentType>(std::forward<Args>(args)...);
          m_uiContext.setContent(std::move(content));
          
          // è®¾ç½®ComboBoxçš„èœå•å¤„ç†å™¨
          setupMenuHandlers();
      }
      
      // === æ¸²æŸ“ ===
      void renderContent();
      
      // === çª—å£æ˜¾ç¤º ===
      void show();
      void hide();
      bool isVisible() const;
      void showModal();
      void closeModal();
      void closeWithResult(WindowContentResult result);
      void setResultCallback(DialogResultCallback callback);
      
      // === äº‹ä»¶å¤„ç† ===
      void handleNativeEvent(void* event);
      void onResize(int width, int height);
      
      // === è®¿é—®å™¨ ===
      bool shouldClose() override;
      Vec2 getSize() const override;
      Vec2 getMousePosition() const override;
      bool isMousePressed() const override;
      void* getNativeWindowHandle() const override;
      Vec2 getWindowPosition() const override;
      Vec2 mapToScreen(const Vec2& windowPos) const override;
      
      // === IMEæ”¯æŒ ===
      void enableTextInput() override;
      void disableTextInput() override;
      void setIMEEnabled(bool enabled) override;
      void handleMarkedText(const char* text, int cursorPos, int selectionLength);
      void handleUnmarkText();
      Rect getInputMethodCursorRect() const;
      
      // === è®¿é—®UIContextï¼ˆç»™å­ç±»ç”¨ï¼‰ ===
      UIContext& getUIContext() { return m_uiContext; }
      const UIContext& getUIContext() const { return m_uiContext; }
  
  private:
      bool initializeRenderer();
      void setupMenuHandlers();
      
      std::unique_ptr<WindowImpl> m_impl;
      std::unique_ptr<IGraphicsBackend> m_backend;    // æ”¹ï¼šæŠ½è±¡åç«¯
      UIContext m_uiContext;                          // æ–°å¢ï¼šUIä¸Šä¸‹æ–‡
      std::unique_ptr<EventManager> m_eventManager;
      
      Window* m_parentWindow;
      WindowType m_windowType;
      WindowState m_state;
      bool m_shouldClose;
      int m_width;
      int m_height;
      float m_dpiScale;
      DialogResultCallback m_resultCallback;
      bool m_isModal;
  };
  
  } // namespace YuchenUI
  ```

  **æ–‡ä»¶**: `platform/src/windows/BaseWindow.cpp`

  **å…³é”®æ”¹åŠ¨ï¼š**

  ```cpp
  #include "YuchenUI/windows/BaseWindow.h"
  #include "YuchenUI/IUIContent.h"               // æ–°å¢
  #include "YuchenUI/platform/PlatformBackend.h"
  #include "YuchenUI/platform/WindowImpl.h"
  #include "YuchenUI/platform/EventManager.h"
  #include "YuchenUI/rendering/RenderList.h"
  #include "YuchenUI/theme/ThemeManager.h"
  #include "YuchenUI/widgets/ComboBox.h"  // ä¸ºäº†è®¾ç½®èœå•handler
  #include "YuchenUI/menu/Menu.h"
  
  // æ„é€ å‡½æ•°
  BaseWindow::BaseWindow(WindowType type)
      : m_impl(nullptr)
      , m_backend(nullptr)          // æ”¹
      , m_uiContext()                // æ–°å¢
      , m_eventManager(nullptr)
      , m_parentWindow(nullptr)
      , m_windowType(type)
      , m_state(WindowState::Uninitialized)
      , m_shouldClose(false)
      , m_width(0)
      , m_height(0)
      , m_dpiScale(1.0f)
      , m_resultCallback(nullptr)
      , m_isModal(false)
  {
      m_impl.reset(WindowImplFactory::create());
  }
  
  // createæ–¹æ³•
  bool BaseWindow::create(int width, int height, const char* title, Window* parent) {
      m_parentWindow = parent;
      m_width = width;
      m_height = height;
      
      WindowConfig config(width, height, title, parent, m_windowType);
      
      if (!m_impl->create(config)) {
          return false;
      }
      m_impl->setBaseWindow(this);
      
      // æ£€æµ‹DPI
      m_dpiScale = m_impl->getDpiScale();
      m_uiContext.setDPIScale(m_dpiScale);
      m_uiContext.setViewportSize(Vec2(width, height));
      
      // åˆå§‹åŒ–æ¸²æŸ“å™¨
      if (!initializeRenderer()) {
          return false;
      }
      
      // åˆ›å»ºäº‹ä»¶ç®¡ç†å™¨
      m_eventManager.reset(PlatformBackend::createEventManager(m_impl->getNativeHandle()));
      if (!m_eventManager->initialize()) {
          return false;
      }
      
      m_eventManager->setEventCallback([this](const Event& event) {
          this->handleEvent(event);
      });
      
      m_state = WindowState::Created;
      m_state = WindowState::RendererReady;
      
      if (m_windowType == WindowType::Main) {
          show();
      }
      
      return true;
  }
  
  // initializeRendereræ”¹åŠ¨
  bool BaseWindow::initializeRenderer() {
      // åˆ›å»ºå¹³å°åç«¯ï¼ˆè¿”å›IGraphicsBackend*ï¼‰
      m_backend.reset(PlatformBackend::createGraphicsBackend());
      
      if (!m_backend) {
          return false;
      }
      
      // åˆå§‹åŒ–ï¼ˆå¹³å°ç›¸å…³ï¼‰
      // MetalRendereråœ¨è‡ªå·±çš„æ„é€ å‡½æ•°ä¸­å·²è®¾ç½®surfaceç­‰
      
      return true;
  }
  
  // renderContentæ”¹åŠ¨
  void BaseWindow::renderContent() {
      if (!m_backend || m_state < WindowState::Created) {
          return;
      }
      
      m_backend->beginFrame();
      
      RenderList commandList;
      Vec4 bgColor = ThemeManager::getInstance().getCurrentStyle()
          ->getWindowBackground(m_windowType);
      commandList.clear(bgColor);
      
      m_uiContext.beginFrame();
      m_uiContext.render(commandList);
      m_uiContext.endFrame();
      
      m_backend->executeRenderCommands(commandList);
      m_backend->endFrame();
  }
  
  // handleEventæ”¹åŠ¨
  void BaseWindow::handleEvent(const Event& event) {
      bool handled = false;
      
      switch (event.type) {
          case EventType::MouseButtonPressed:
          case EventType::MouseButtonReleased:
              handled = m_uiContext.handleMouseClick(
                  event.mouseButton.position,
                  event.type == EventType::MouseButtonPressed
              );
              break;
              
          case EventType::MouseMoved:
              handled = m_uiContext.handleMouseMove(event.mouseMove.position);
              break;
              
          case EventType::MouseScrolled:
              handled = m_uiContext.handleMouseWheel(
                  event.mouseScroll.delta,
                  event.mouseScroll.position
              );
              break;
              
          case EventType::KeyPressed:
          case EventType::KeyReleased:
              handled = m_uiContext.handleKeyEvent(
                  event.key.key,
                  event.type == EventType::KeyPressed,
                  event.key.modifiers,
                  event.key.isRepeat
              );
              break;
              
          case EventType::TextInput:
              handled = m_uiContext.handleTextInput(event.textInput.codepoint);
              break;
              
          case EventType::TextComposition:
              handled = m_uiContext.handleTextComposition(
                  event.textComposition.text,
                  event.textComposition.cursorPosition,
                  event.textComposition.selectionLength
              );
              break;
              
          case EventType::WindowClosed:
              m_shouldClose = true;
              break;
              
          case EventType::WindowResized:
              onResize((int)event.window.size.x, (int)event.window.size.y);
              break;
              
          default:
              break;
      }
  }
  
  // onResizeæ”¹åŠ¨
  void BaseWindow::onResize(int width, int height) {
      if (width != m_width || height != m_height) {
          m_width = width;
          m_height = height;
          m_uiContext.setViewportSize(Vec2(width, height));
      }
  }
  
  // IMEæ”¯æŒ
  Rect BaseWindow::getInputMethodCursorRect() const {
      return m_uiContext.getInputMethodCursorRect();
  }
  
  // èœå•å¤„ç†å™¨è®¾ç½®ï¼ˆæ–°å¢ï¼‰
  void BaseWindow::setupMenuHandlers() {
      auto* content = m_uiContext.getContent();
      if (!content) return;
      
      // éå†å†…å®¹ä¸­çš„æ‰€æœ‰ç»„ä»¶ï¼Œæ‰¾åˆ°ComboBoxè®¾ç½®handler
      // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…å¯èƒ½éœ€è¦é€’å½’éå†
      // ï¼ˆæˆ–è€…åœ¨ComboBoxæ„é€ æ—¶è‡ªåŠ¨ä»contextè·å–handlerï¼‰
  }
  ```

  #### 5.3.2 é‡æ„MetalRenderer

  **æ–‡ä»¶**: `platform/src/macos/MetalRenderer.h`

  **æ”¹åŠ¨æ¸…å•ï¼š**

  ```cpp
  // ã€æ”¹ã€‘ç»§æ‰¿æ¥å£
  class MetalRenderer : public IGraphicsBackend {  // æ”¹ï¼šä¸å†ç»§æ‰¿GraphicsContext
  public:
      MetalRenderer();
      ~MetalRenderer() override;
      
      // === å®ç°IGraphicsBackendæ¥å£ ===
      void beginFrame() override;
      void endFrame() override;
      void executeRenderCommands(const RenderList& commands) override;
      
      void* createTexture2D(uint32_t width, uint32_t height, TextureFormat format) override;
      void updateTexture2D(void* texture, uint32_t x, uint32_t y,
                          uint32_t width, uint32_t height,
                          const void* data, size_t bytesPerRow) override;
      void destroyTexture(void* texture) override;
      
      Vec2 getRenderSize() const override;
      float getDPIScale() const override;
      
      // === å¹³å°ç‰¹å®šï¼ˆä¸åœ¨æ¥å£ä¸­ï¼‰ ===
      bool initialize(void* metalLayer, int width, int height, float dpiScale);
      void resize(int width, int height);
  
  private:
      // Metalç›¸å…³æˆå‘˜ä¿æŒä¸å˜
  };
  ```

  **æ–‡ä»¶**: `platform/src/macos/MetalRenderer.mm`

  **æ”¹åŠ¨è¦ç‚¹ï¼š**

  1. åˆ é™¤`setSurface()`å’Œ`setSharedDevice()`æ–¹æ³•
  2. æ”¹ä¸ºåœ¨`initialize()`ä¸­ç›´æ¥æ¥æ”¶å‚æ•°
  3. å…¶ä»–å®ç°åŸºæœ¬ä¿æŒä¸å˜

  ```cpp
  bool MetalRenderer::initialize(void* metalLayer, int width, int height, float dpiScale) {
      m_metalLayer = (__bridge CAMetalLayer*)metalLayer;
      m_width = width;
      m_height = height;
      m_dpiScale = dpiScale;
      
      // é…ç½®Metal layer
      m_metalLayer.device = m_device;
      m_metalLayer.pixelFormat = MTLPixelFormatBGRA8Unorm;
      m_metalLayer.drawableSize = CGSizeMake(width * dpiScale, height * dpiScale);
      
      // å…¶ä»–åˆå§‹åŒ–...
      
      m_isInitialized = true;
      return true;
  }
  ```

  #### 5.3.3 æ›´æ–°PlatformBackend

  **æ–‡ä»¶**: `platform/include/YuchenUI/platform/PlatformBackend.h`

  ```cpp
  #pragma once
  
  namespace YuchenUI {
  
  class IGraphicsBackend;  // æ”¹ï¼šè¿”å›æŠ½è±¡æ¥å£
  class EventManager;
  
  class PlatformBackend {
  public:
      // æ”¹ï¼šè¿”å›IGraphicsBackend*
      static IGraphicsBackend* createGraphicsBackend();
      
      static EventManager* createEventManager(void* nativeWindow);
      
      // å…±äº«è®¾å¤‡ç›¸å…³ä¿æŒä¸å˜ï¼ˆå¯é€‰ï¼‰
      static void* createSharedDevice();
      static void destroySharedDevice(void* device);
  };
  
  } // namespace YuchenUI
  ```

  **æ–‡ä»¶**: `platform/src/macos/PlatformBackend.mm`

  ```cpp
  #include "YuchenUI/platform/PlatformBackend.h"
  #include "MetalRenderer.h"
  #include "MacEventManager.h"
  
  namespace YuchenUI {
  
  IGraphicsBackend* PlatformBackend::createGraphicsBackend() {
      return new MetalRenderer();  // è¿”å›å®ç°ç±»æŒ‡é’ˆ
  }
  
  EventManager* PlatformBackend::createEventManager(void* nativeWindow) {
      return new MacEventManager((__bridge NSWindow*)nativeWindow);
  }
  
  // ... å…¶ä»–æ–¹æ³•ä¿æŒä¸å˜
  }
  ```

  #### 5.3.4 ç®€åŒ–EventManager

  **æ–‡ä»¶**: `platform/include/YuchenUI/events/EventManager.h`

  **æ”¹åŠ¨ï¼šå»æ‰é˜Ÿåˆ—å’Œå›è°ƒï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰**

  å¦‚æœæƒ³å½»åº•ç®€åŒ–EventManagerä¸ºçº¯è½¬æ¢å™¨ï¼š

  ```cpp
  class EventManager {
  public:
      virtual ~EventManager() = default;
      
      virtual bool initialize() = 0;
      virtual void destroy() = 0;
      
      // çº¯è½¬æ¢æ–¹æ³•ï¼ˆæ–°å¢ï¼‰
      virtual Event convertNativeEvent(void* nativeEvent) = 0;
      
      // ä¿ç•™çš„æŸ¥è¯¢æ–¹æ³•
      virtual bool isKeyPressed(KeyCode key) const = 0;
      virtual bool isMouseButtonPressed(MouseButton button) const = 0;
      virtual Vec2 getMousePosition() const = 0;
      virtual KeyModifiers getCurrentModifiers() const = 0;
  };
  ```

  ä½†ä¸ºäº†ç®€åŒ–å·¥ä½œï¼Œ**å»ºè®®ä¿æŒEventManagerä¸å˜**ï¼Œåªæ˜¯BaseWindowä¸å†ä½¿ç”¨é˜Ÿåˆ—ï¼Œè€Œæ˜¯ç›´æ¥åœ¨å›è°ƒä¸­è½¬å‘ã€‚

  ------

  ### 5.4 Phase 4: CMakeé…ç½®

  #### 5.4.1 Coreå±‚CMakeLists.txt

  **æ–‡ä»¶**: `core/CMakeLists.txt`

  ```cmake
  cmake_minimum_required(VERSION 3.15)
  project(YuchenUI_Core)
  
  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  
  # æºæ–‡ä»¶
  set(CORE_SOURCES
      # æ ¸å¿ƒ
      src/UIContext.cpp
      src/IUIContent.cpp
      
      # Widget
      src/widgets/UIComponent.cpp
      src/widgets/Widget.cpp
      src/widgets/Button.cpp
      src/widgets/TextLabel.cpp
      src/widgets/TextBlock.cpp
      src/widgets/Frame.cpp
      src/widgets/GroupBox.cpp
      src/widgets/Image.cpp
      src/widgets/CheckBox.cpp
      src/widgets/RadioButton.cpp
      src/widgets/ComboBox.cpp
      src/widgets/SpinBox.cpp
      src/widgets/ScrollArea.cpp
      src/widgets/TextInput.cpp
      
      # ç„¦ç‚¹
      src/focus/FocusManager.cpp
      
      # èœå•
      src/menu/Menu.cpp
      src/menu/MenuItem.cpp
      
      # æ¸²æŸ“
      src/rendering/RenderList.cpp
      
      # æ–‡æœ¬
      src/text/Font.cpp
      src/text/FontManager.cpp
      src/text/TextRenderer.cpp
      src/text/GlyphCache.cpp
      src/text/TextUtils.cpp
      
      # ä¸»é¢˜
      src/theme/Theme.cpp
      src/theme/ThemeManager.cpp
      
      # å›¾åƒ
      src/image/ImageDecoder.cpp
      src/image/TextureCache.cpp
  )
  
  # åˆ›å»ºåº“
  add_library(YuchenUI_Core STATIC ${CORE_SOURCES})
  
  # å¤´æ–‡ä»¶è·¯å¾„
  target_include_directories(YuchenUI_Core PUBLIC
      ${CMAKE_CURRENT_SOURCE_DIR}/include
  )
  
  # ä¾èµ–ï¼šFreeType
  find_package(Freetype REQUIRED)
  target_link_libraries(YuchenUI_Core PUBLIC Freetype::Freetype)
  
  # ä¾èµ–ï¼šHarfBuzz
  find_package(harfbuzz REQUIRED)
  target_link_libraries(YuchenUI_Core PUBLIC harfbuzz::harfbuzz)
  
  # ç¼–è¯‘é€‰é¡¹
  if(MSVC)
      target_compile_options(YuchenUI_Core PRIVATE /W4)
  else()
      target_compile_options(YuchenUI_Core PRIVATE -Wall -Wextra)
  endif()
  ```

  #### 5.4.2 Platformå±‚CMakeLists.txt

  **æ–‡ä»¶**: `platform/CMakeLists.txt`

  ```cmake
  cmake_minimum_required(VERSION 3.15)
  project(YuchenUI_Platform)
  
  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  
  # å¹³å°æ£€æµ‹
  if(APPLE)
      set(PLATFORM_SOURCES
          src/windows/BaseWindow.cpp
          src/windows/WindowManager.cpp
          src/macos/MacOSWindowImpl.mm
          src/macos/MacEventManager.mm
          src/macos/MetalRenderer.mm
          src/macos/MacMenuImpl.mm
          src/macos/PlatformBackend.mm
      )
      
      set(PLATFORM_FRAMEWORKS
          "-framework Cocoa"
          "-framework Metal"
          "-framework MetalKit"
          "-framework QuartzCore"
      )
  elseif(WIN32)
      # Windowså¹³å°æºæ–‡ä»¶ï¼ˆå¾…å®ç°ï¼‰
      set(PLATFORM_SOURCES
          src/windows/BaseWindow.cpp
          src/windows/WindowManager.cpp
          # ... Win32å®ç°
      )
  endif()
  
  # åˆ›å»ºåº“
  add_library(YuchenUI_Platform STATIC ${PLATFORM_SOURCES})
  
  # ä¾èµ–Coreå±‚
  target_link_libraries(YuchenUI_Platform PUBLIC YuchenUI_Core)
  
  # å¤´æ–‡ä»¶è·¯å¾„
  target_include_directories(YuchenUI_Platform PUBLIC
      ${CMAKE_CURRENT_SOURCE_DIR}/include
  )
  
  # å¹³å°æ¡†æ¶
  if(APPLE)
      target_link_libraries(YuchenUI_Platform PUBLIC ${PLATFORM_FRAMEWORKS})
  endif()
  
  # ç¼–è¯‘é€‰é¡¹
  if(APPLE)
      target_compile_options(YuchenUI_Platform PRIVATE
          -Wall -Wextra
          -fobjc-arc  # ARCæ”¯æŒ
      )
  endif()
  ```

  #### 5.4.3 æ ¹CMakeLists.txt

  **æ–‡ä»¶**: `CMakeLists.txt`

  ```cmake
  cmake_minimum_required(VERSION 3.15)
  project(YuchenUI VERSION 1.0.0)
  
  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  
  # é€‰é¡¹
  option(YUCHEN_BUILD_CORE_ONLY "Build only the Core library" OFF)
  option(YUCHEN_BUILD_PLATFORM "Build Platform layer" ON)
  option(YUCHEN_BUILD_EXAMPLES "Build examples" ON)
  
  # Coreå±‚ï¼ˆå¿…é¡»ï¼‰
  add_subdirectory(core)
  
  # Platformå±‚ï¼ˆå¯é€‰ï¼‰
  if(YUCHEN_BUILD_PLATFORM)
      add_subdirectory(platform)
  endif()
  
  # ç¤ºä¾‹
  if(YUCHEN_BUILD_EXAMPLES)
      add_subdirectory(examples)
  endif()
  
  # åˆ›å»ºæ€»åº“ï¼ˆå…¼å®¹æ€§ï¼‰
  add_library(YuchenUI INTERFACE)
  target_link_libraries(YuchenUI INTERFACE YuchenUI_Core)
  
  if(YUCHEN_BUILD_PLATFORM)
      target_link_libraries(YuchenUI INTERFACE YuchenUI_Platform)
  endif()
  ```

  ------

  ## 6. æµ‹è¯•éªŒè¯

  ### 6.1 Coreå±‚ç‹¬ç«‹ç¼–è¯‘æµ‹è¯•

  ```bash
  # éªŒè¯Coreå¯ä»¥ç‹¬ç«‹ç¼–è¯‘
  cd core
  mkdir build && cd build
  cmake .. -DCMAKE_BUILD_TYPE=Debug
  make
  
  # åº”è¯¥æˆåŠŸç¼–è¯‘ï¼Œä¸æŠ¥é”™
  ```

  ### 6.2 ä¾èµ–æ£€æŸ¥

  ```bash
  # æ£€æŸ¥Coreå±‚æ˜¯å¦åŒ…å«Platformå¤´æ–‡ä»¶
  cd core/include
  grep -r "windows/" . && echo "âŒ Coreä¾èµ–Platformï¼" || echo "âœ… Coreç‹¬ç«‹"
  grep -r "platform/" . && echo "âŒ Coreä¾èµ–Platformï¼" || echo "âœ… Coreç‹¬ç«‹"
  
  # æ£€æŸ¥Platformå±‚æ˜¯å¦æ­£ç¡®ä¾èµ–Core
  cd platform/src
  grep -r "YuchenUI/UIContext.h" . && echo "âœ… Platformä½¿ç”¨Core" || echo "âŒ Platformæœªä½¿ç”¨Core"
  ```

  ### 6.3 åŠŸèƒ½æµ‹è¯•

  #### æµ‹è¯•1ï¼šçº¯UIæ¨¡å¼ï¼ˆGLFWï¼‰

  ```cpp
  // examples/glfw_pure/main.cpp
  #include <YuchenUI/UIContext.h>
  #include <YuchenUI/IUIContent.h>
  #include <YuchenUI/widgets/Button.h>
  #include <GLFW/glfw3.h>
  
  class TestContent : public YuchenUI::IUIContent {
  public:
      void onCreate(YuchenUI::UIContext* context, const YuchenUI::Rect& area) override {
          m_context = context;
          m_contentArea = area;
          
          // åˆ›å»ºæŒ‰é’®
          auto* button = new YuchenUI::Button(YuchenUI::Rect(10, 10, 100, 30));
          button->setText("Click Me");
          button->setOwnerContext(context);
          addComponent(button);
      }
      
      void render(YuchenUI::RenderList& commandList) override {
          commandList.clear(YuchenUI::Colors::DEFAULT_CLEAR_COLOR);
          
          for (auto* comp : m_components) {
              if (comp && comp->isVisible()) {
                  comp->addDrawCommands(commandList);
              }
          }
      }
  };
  
  int main() {
      glfwInit();
      GLFWwindow* window = glfwCreateWindow(800, 600, "Pure UI Test", nullptr, nullptr);
      
      YuchenUI::UIContext uiContext;
      uiContext.setViewportSize(YuchenUI::Vec2(800, 600));
      uiContext.setContent(std::make_unique<TestContent>());
      
      while (!glfwWindowShouldClose(window)) {
          uiContext.beginFrame();
          
          YuchenUI::RenderList commandList;
          uiContext.render(commandList);
          
          // TODO: æ‰§è¡ŒOpenGLæ¸²æŸ“
          
          uiContext.endFrame();
          
          glfwSwapBuffers(window);
          glfwPollEvents();
      }
      
      glfwTerminate();
      return 0;
  }
  ```

  #### æµ‹è¯•2ï¼šPlatformæ¨¡å¼

  ```cpp
  // examples/native_window/main.cpp
  #include <YuchenUI/windows/WindowManager.h>
  #include <YuchenUI/windows/BaseWindow.h>
  #include <YuchenUI/IUIContent.h>
  #include <YuchenUI/widgets/Button.h>
  
  class TestContent : public YuchenUI::IUIContent {
  public:
      void onCreate(YuchenUI::UIContext* context, const YuchenUI::Rect& area) override {
          m_context = context;
          
          auto* button = new YuchenUI::Button(YuchenUI::Rect(10, 10, 150, 40));
          button->setText("Native Window Test");
          button->setOwnerContext(context);
          addComponent(button);
      }
      
      void render(YuchenUI::RenderList& commandList) override {
          for (auto* comp : m_components) {
              if (comp && comp->isVisible()) {
                  comp->addDrawCommands(commandList);
              }
          }
      }
  };
  
  int main() {
      YuchenUI::WindowManager::getInstance().initialize();
      
      auto* mainWindow = YuchenUI::WindowManager::getInstance()
          .createMainWindow<TestContent>(800, 600, "Platform Test");
      
      mainWindow->show();
      
      YuchenUI::WindowManager::getInstance().run();
      return 0;
  }
  ```

  ### 6.4 å›å½’æµ‹è¯•æ¸…å•

  | åŠŸèƒ½          | Coreæµ‹è¯•       | Platformæµ‹è¯• |
  | ------------- | -------------- | ------------ |
  | Buttonç‚¹å‡»    | âœ…              | âœ…            |
  | TextInputè¾“å…¥ | âœ…              | âœ…            |
  | ç„¦ç‚¹Tabåˆ‡æ¢   | âœ…              | âœ…            |
  | é¼ æ ‡æ‹–åŠ¨      | âœ…              | âœ…            |
  | æ»šåŠ¨åŒºåŸŸ      | âœ…              | âœ…            |
  | ComboBoxä¸‹æ‹‰  | âš ï¸éœ€æ³¨å…¥handler | âœ…            |
  | ä¸­æ–‡è¾“å…¥(IME) | N/A            | âœ…            |
  | å¼¹å‡ºå¯¹è¯æ¡†    | N/A            | âœ…            |

  ------

  ## 7. å·¥ä½œåˆ†é…å»ºè®®

  ### 7.1 å¹¶è¡Œä»»åŠ¡åˆ†é…ï¼ˆ3äººå›¢é˜Ÿï¼‰

  #### **å¼€å‘è€…Aï¼šCoreå±‚åŸºç¡€**

  - **Day 1-2**: åˆ›å»ºUIContext/IUIContent/IGraphicsBackend
  - **Day 3**: é‡æ„UIComponent/Widget
  - **Day 4-5**: æ‰¹é‡ä¿®æ”¹æ‰€æœ‰Widget
  - **é£é™©**: UIContextè®¾è®¡ä¸å½“ä¼šå½±å“åç»­

  #### **å¼€å‘è€…Bï¼šPlatformå±‚æ”¹é€ **

  - **Day 1**: ç­‰å¾…Aå®ŒæˆUIContext
  - **Day 2-3**: é‡æ„BaseWindow
  - **Day 4**: é‡æ„MetalRenderer
  - **Day 5**: æµ‹è¯•Platformæ¨¡å¼
  - **ä¾èµ–**: éœ€è¦Açš„UIContextå®Œæˆ

  #### **å¼€å‘è€…Cï¼šæµ‹è¯•å’Œæ–‡æ¡£**

  - **Day 1-2**: ç¼–å†™Coreå±‚å•å…ƒæµ‹è¯•
  - **Day 3**: ç¼–å†™GLFWç¤ºä¾‹
  - **Day 4**: ç¼–å†™Platformæµ‹è¯•
  - **Day 5**: å›å½’æµ‹è¯•å’Œé—®é¢˜ä¿®å¤

  ### 7.2 ä¸²è¡Œä»»åŠ¡ï¼ˆ1äººå›¢é˜Ÿï¼‰

  | é˜¶æ®µ   | ä»»åŠ¡         | æ—¶é—´ |
  | ------ | ------------ | ---- |
  | Week 1 | CoreåŸºç¡€     | 5å¤©  |
  | Week 2 | Widgeté‡æ„   | 3å¤©  |
  |        | Platformæ”¹é€  | 2å¤©  |
  | Week 3 | æµ‹è¯•éªŒè¯     | 3å¤©  |
  |        | é—®é¢˜ä¿®å¤     | 2å¤©  |

  ### 7.3 é‡Œç¨‹ç¢‘æ£€æŸ¥ç‚¹

  **Checkpoint 1 (Day 2)**: CoreåŸºç¡€å®Œæˆ

  - âœ… UIContextå¯ç¼–è¯‘
  - âœ… IUIContentå®šä¹‰æ˜ç¡®
  - âœ… IGraphicsBackendæ¥å£æ¸…æ™°

  **Checkpoint 2 (Day 5)**: Widgeté‡æ„å®Œæˆ

  - âœ… æ‰€æœ‰Widgetç¼–è¯‘é€šè¿‡
  - âœ… Coreå±‚ç‹¬ç«‹ç¼–è¯‘æˆåŠŸ
  - âœ… æ— Platformä¾èµ–

  **Checkpoint 3 (Day 8)**: Platformæ”¹é€ å®Œæˆ

  - âœ… BaseWindowç¼–è¯‘é€šè¿‡
  - âœ… MetalRendererå®ç°IGraphicsBackend
  - âœ… Platformæµ‹è¯•é€šè¿‡

  **Checkpoint 4 (Day 10)**: æµ‹è¯•å®Œæˆ

  - âœ… æ‰€æœ‰å›å½’æµ‹è¯•é€šè¿‡
  - âœ… GLFWç¤ºä¾‹å¯è¿è¡Œ
  - âœ… Platformæ¨¡å¼å¯è¿è¡Œ

  ------

  ## 8. é£é™©å’Œåº”å¯¹

  ### 8.1 é«˜é£é™©é¡¹

  | é£é™©              | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½                      |
  | ----------------- | ---- | ---- | ----------------------------- |
  | UIContextè®¾è®¡ç¼ºé™· | é«˜   | ä¸¥é‡ | æå‰è®¾è®¡è¯„å®¡ï¼Œå†™åŸå‹éªŒè¯      |
  | å¾ªç¯ä¾èµ–          | ä¸­   | ä¸¥é‡ | ä¸¥æ ¼æ£€æŸ¥includeï¼Œä½¿ç”¨å‰å‘å£°æ˜ |
  | ç„¦ç‚¹ç³»ç»Ÿç ´å      | ä¸­   | ä¸­ç­‰ | å•ç‹¬æµ‹è¯•ç„¦ç‚¹åŠŸèƒ½              |
  | IMEè¾“å…¥å¤±æ•ˆ       | ä½   | ä¸­ç­‰ | macOSæµ‹è¯•ä¸­æ–‡è¾“å…¥             |

  ### 8.2 åº”å¯¹ç­–ç•¥

  1. **è®¾è®¡è¯„å®¡**ï¼šPhase 1å¼€å§‹å‰ï¼Œå›¢é˜Ÿè¯„å®¡UIContextè®¾è®¡
  2. **å¢é‡æµ‹è¯•**ï¼šæ¯ä¸ªPhaseç»“æŸåç¼–è¯‘æµ‹è¯•
  3. **Gitåˆ†æ”¯**ï¼šä½¿ç”¨`feature/core-refactor`åˆ†æ”¯ï¼Œä¿ç•™ä¸»åˆ†æ”¯
  4. **ä»£ç å®¡æŸ¥**ï¼šå…³é”®æ–‡ä»¶ç”±ä¸¤äººreview

  ------

  ## 9. é™„å½•

  ### 9.1 å¿«é€Ÿå‚è€ƒ

  **Coreå±‚å…³é”®ç±»ï¼š**

  - `UIContext` - æ ¸å¿ƒå…¥å£
  - `IUIContent` - å†…å®¹æ¥å£
  - `IGraphicsBackend` - æ¸²æŸ“æŠ½è±¡
  - `UIComponent` - ç»„ä»¶åŸºç±»

  **Platformå±‚å…³é”®ç±»ï¼š**

  - `BaseWindow` - çª—å£æ‰˜ç®¡UIContext
  - `MetalRenderer` - å®ç°IGraphicsBackend
  - `WindowManager` - çª—å£ç®¡ç†å™¨

  **ä¾èµ–è§„åˆ™ï¼š**

  ```
  Platform â†’ Core  âœ…
  Core â†’ Platform  âŒ
  ```

  ### 9.2 å¸¸è§é—®é¢˜

  **Q: TextInputå¦‚ä½•è§¦å‘IMEï¼Ÿ** A: é€šè¿‡focusInEventå›è°ƒï¼Œè°ƒç”¨IUIContent::requestTextInput()ï¼Œç”±Platformå±‚å¤„ç†ã€‚

  **Q: ComboBoxå¦‚ä½•å¼¹å‡ºèœå•ï¼Ÿ** A: æ³¨å…¥MenuPopupHandlerï¼Œç”±Platformå±‚å®ç°åŸç”Ÿå¼¹å‡ºã€‚

  **Q: å¦‚ä½•ç¡®ä¿Coreä¸ä¾èµ–Platformï¼Ÿ** A: ä½¿ç”¨æŠ½è±¡æ¥å£ï¼ˆIGraphicsBackendï¼‰ï¼Œå®šä¹‰åœ¨Coreï¼Œå®ç°åœ¨Platformã€‚

  ------

  **æ–‡æ¡£ç»“æŸ**
